<?xml version="1.0" encoding="utf-8"?>
<letsmt version="1.0">
<head></head>
<body>
<p id="1">
<s id="1">LetsMT!</s>
<s id="2">Platform for Online Sharing of Training Data and Building User Tailored MT www.letsmt.eu/</s>
</p>
<p id="2">
<s id="3">Project no.</s>
<s id="4">250456</s>
</p>
<p id="3">
<s id="5">Deliverable D2.1 Speciﬁcation of data formats Version No. v1.1</s>
</p>
<p id="4">
<s id="6">May 25, 2011</s>
</p>
<p id="5">
<s id="7">1</s>
</p>
<p id="6">
<s id="8">Contract no.</s>
<s id="9">250456 Document Information</s>
<s id="10">Deliverable number: Deliverable title: Due date of deliverable according to DoW:</s>
</p>
<p id="7">
<s id="11">D2.1 Speciﬁcation of data formats 31/08/2010</s>
</p>
<p id="8">
<s id="12">Actual submission date of deliverable:</s>
</p>
<p id="9">
<s id="13">31/08/2010</s>
</p>
<p id="10">
<s id="14">Main Author(s):</s>
</p>
<p id="11">
<s id="15">J¨ rg Tiedemann, Per Weijnitz o</s>
</p>
<p id="12">
<s id="16">Participants: Reviewer Workpackage: Workpackage title:</s>
</p>
<p id="13">
<s id="17">Uppsala Tilde, Moravia WP2 SMT resource repository and data processing facili- ties</s>
</p>
<p id="14">
<s id="18">Workpackage leader: Dissemination Level: Version: Keywords:</s>
</p>
<p id="15">
<s id="19">Uppsala PU v1.1 data formats</s>
</p>
<p id="16">
<s id="20">Version History</s>
</p>
<p id="17">
<s id="21">Version</s>
</p>
<p id="18">
<s id="22">Date</s>
</p>
<p id="19">
<s id="23">Status</s>
</p>
<p id="20">
<s id="24">Name of Au- thor (Partner)</s>
</p>
<p id="21">
<s id="25">Contribu- tions</s>
</p>
<p id="22">
<s id="26">Description/ Approval Level</s>
</p>
<p id="23">
<s id="27">v0.1</s>
</p>
<p id="24">
<s id="28">July 17, 2010</s>
</p>
<p id="25">
<s id="29">initial draft</s>
</p>
<p id="26">
<s id="30">Uppsala</s>
</p>
<p id="27">
<s id="31">ready for re- viewing</s>
</p>
<p id="28">
<s id="32">v0.2</s>
</p>
<p id="29">
<s id="33">August 17, 2010</s>
</p>
<p id="30">
<s id="34">ﬁnal draft</s>
</p>
<p id="31">
<s id="35">Uppsala</s>
</p>
<p id="32">
<s id="36">v1.0</s>
</p>
<p id="33">
<s id="37">August 30, 2010</s>
</p>
<p id="34">
<s id="38">ﬁnal version</s>
</p>
<p id="35">
<s id="39">Uppsala</s>
</p>
<p id="36">
<s id="40">approved by all partners</s>
</p>
<p id="37">
<s id="41">v1.1</s>
</p>
<p id="38">
<s id="42">May 23, 2011</s>
</p>
<p id="39">
<s id="43">revised version</s>
</p>
<p id="40">
<s id="44">Uppsala</s>
</p>
<p id="41">
<s id="45">EXECUTIVE SUMMARY This is a description of data formats that will be used internally in the LetsMT! data resource repository and data formats that will be allowed when uploading parallel and monolingual data to the LetsMT! platform.</s>
<s id="46">The report includes a discussion of issues that have to be handled for various formats and points to solutions and tools that will be used in the project.</s>
</p>
<p id="42">
<s id="47">D2.1— v1.1</s>
</p>
<p id="43">
<s id="48">2</s>
</p>
<p id="44">
<s id="49">Contract no.</s>
<s id="50">250456</s>
</p>
<p id="45">
<s id="51">Contents 1</s>
</p>
<p id="46">
<s id="52">Task Description</s>
</p>
<p id="47">
<s id="53">5</s>
</p>
<p id="48">
<s id="54">2</s>
</p>
<p id="49">
<s id="55">Internal Storage Formats 2.1 Corpus Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</s>
<s id="56">2.2 Alignment Information . . . . . . . . . . . . . . . . . . . . . . .</s>
<s id="57">2.3 Repository Structure . . . . . . . . . . . . . . . . . . . . . . . .</s>
</p>
<p id="50">
<s id="58">5 5 7 9</s>
</p>
<p id="51">
<s id="59">2</s>
</p>
<p id="52">
<s id="60">.4 Revisions &amp; Corpus Selections . . . . . . . . . . . . . . . . . . .</s>
</p>
<p id="53">
<s id="61">10</s>
</p>
<p id="54">
<s id="62">3</s>
</p>
<p id="55">
<s id="63">Upload Formats 3.1 Pre-aligned Parallel Corpora . . . . . . . . . . . . . . . . . . . .</s>
<s id="64">3.1.1 Translation Memory eXchange format (TMX) . . . . . .</s>
<s id="65">3.1.2 Plain text Giza++/Moses format . . . . . . . . . . . . . .</s>
<s id="66">3.1.3 Factored Moses format . . . . . . . . . . . . . . . . . . .</s>
<s id="67">3.1.4 XML Localization Interchange File Format (XLIFF) . . .</s>
<s id="68">3.1.5 LetsMT!-conform XML/XCES . . . . . . . . . . . . . .</s>
<s id="69">3.2 Unaligned Parallel Documents . . . . . . . . . . . . . . . . . . .</s>
<s id="70">3.2.1 Microsoft Word DOC &amp; DOCX . . . . . . . . . . . . . .</s>
<s id="71">3.2.2 Portable Document Format (PDF) . . . . . . . . . . . . .</s>
<s id="72">3.2.3 Plain text . . . . . . . . . . . . . . . . . . . . . . . . . .</s>
<s id="73">3.2.4 Open Document Format (ODF) . . . . . . . . . . . . . .</s>
<s id="74">3.2.5 XML &amp; HTML . . . . . . . . . . . . . . . . . . . . . . .</s>
<s id="75">3.3 Monolingual Data . . . . . . . . . . . . . . . . . . . . . . . . . .</s>
</p>
<p id="56">
<s id="76">12 13 13 17 18 18 19 20 20 21 22 22 23 23</s>
</p>
<p id="57">
<s id="77">4</s>
</p>
<p id="58">
<s id="78">Validation of Data Uploads</s>
</p>
<p id="59">
<s id="79">24</s>
</p>
<p id="60">
<s id="80">5</s>
</p>
<p id="61">
<s id="81">Risk Analysis</s>
</p>
<p id="62">
<s id="82">26</s>
</p>
<p id="63">
<s id="83">6</s>
</p>
<p id="64">
<s id="84">Conclusions</s>
</p>
<p id="65">
<s id="85">27</s>
</p>
<p id="66">
<s id="86">D2.1— v1.1</s>
</p>
<p id="67">
<s id="87">3</s>
</p>
<p id="68">
<s id="88">Contract no.</s>
<s id="89">250456</s>
</p>
<p id="69">
<s id="90">List of Figures</s>
</p>
<p id="70">
<s id="91">1</s>
</p>
<p id="71">
<s id="92">Corpus data after pre-processing</s>
</p>
<p id="72">
<s id="93">. . . . . . . . . . . . . . . . . . .</s>
</p>
<p id="73">
<s id="94">7</s>
</p>
<p id="74">
<s id="95">2</s>
</p>
<p id="75">
<s id="96">Sentence alignments</s>
</p>
<p id="76">
<s id="97">. . . . . . . . . . . . . . . . . . . . . . . . .</s>
</p>
<p id="77">
<s id="98">8</s>
</p>
<p id="78">
<s id="99">3</s>
</p>
<p id="79">
<s id="100">File structure in LetsMT! repositories</s>
</p>
<p id="80">
<s id="101">. . . . . . . . . . . . . . . .</s>
</p>
<p id="81">
<s id="102">11</s>
</p>
<p id="82">
<s id="103">4</s>
</p>
<p id="83">
<s id="104">Classiﬁcation of upload formats</s>
</p>
<p id="84">
<s id="105">. . . . . . . . . . . . . . . . . . .</s>
</p>
<p id="85">
<s id="106">13</s>
</p>
<p id="86">
<s id="107">5</s>
</p>
<p id="87">
<s id="108">Example TMX ﬁle</s>
</p>
<p id="88">
<s id="109">. . . . . . . . . . . . . . . . . . . . . . . . .</s>
</p>
<p id="89">
<s id="110">14</s>
</p>
<p id="90">
<s id="111">6</s>
</p>
<p id="91">
<s id="112">Content markup in TMX ﬁles</s>
</p>
<p id="92">
<s id="113">. . . . . . . . . . . . . . . . . . . .</s>
</p>
<p id="93">
<s id="114">15</s>
</p>
<p id="94">
<s id="115">7 8</s>
</p>
<p id="95">
<s id="116">The general structure of Non-equivalence in XLIFF</s>
</p>
<p id="96">
<s id="117">XLIFF . . .</s>
</p>
<p id="97">
<s id="118">. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</s>
</p>
<p id="98">
<s id="119">18 19</s>
</p>
<p id="99">
<s id="120">List of Tables 1 Preliminary list of and remarks on data format speciﬁc validation</s>
</p>
<p id="100">
<s id="121">and conversion tools. . . . . . . . . . . . . . . . . . . . . . . . .</s>
</p>
<p id="101">
<s id="122">25</s>
</p>
<p id="102">
<s id="123">D2.1— v1.1</s>
</p>
<p id="103">
<s id="124">4</s>
</p>
<p id="104">
<s id="125">Contract no.</s>
<s id="126">250456</s>
</p>
<p id="105">
<s id="127">1 Task Description One of the key functions of the LetsMT! platform is to provide the possibility to train domain speciﬁc SMT models tailored towards speciﬁc needs of its users.</s>
<s id="128">For this appropriate data resources are required.</s>
<s id="129">LetsMT! is based on data sharing and user collaboration.</s>
<s id="130">The scope of workpackage two is to develop facilities to store, process and manage resources coming from LetsMT! users.</s>
<s id="131">The purpose of this report is to specify data formats that will be used internally when storing parallel and monolingual corpus data in the repository and to list data formats that will be supported for the user contributions.</s>
<s id="132">The main focus here is to balance robustness and ﬂexibility, meaning that supported upload formats have to be handled in a sta- ble and robust way.</s>
<s id="133">Each additional formats usually increases complexity of the validation and conversion processes and, therefore, may reduce overall robustness of the system.</s>
<s id="134">Restricting the system to a few well supported formats will lead to user satisfaction more than a brittle system with a lot of possibilities would do.</s>
<s id="135">Adding support for new formats can always be done later on after carefully test- ing the integration of upload possibilities and after checking possible interferences with existing features.</s>
</p>
<p id="106">
<s id="136">2 Internal Storage Formats In this section we will describe the internal data formats that we will use to store training data in the shared repository.</s>
<s id="137">We will use a uniﬁed format for all textual data in the repository which makes it easy to select subsets of the entire collection for training tailored SMT engines.</s>
<s id="138">All incoming data will be converted to this format and possibly enriched using pre-processing tools.</s>
<s id="139">We will also store the raw uploads to ensure data recovery and to make it possible to adjust conversion and pre-processing if necessary.</s>
</p>
<p id="107">
<s id="140">2.1 Corpus Data All corpus data, regardless whether it is part of a parallel corpus or part of a mono- lingual corpus, will be stored in a simple XML format.1 XML is a well-established and widely used markup language for the representation of structured information.</s>
<s id="141">XML comes with ﬁxed standard speciﬁcations [1], naively supports Unicode [9], and the main advantage is that a lot of tools (parsers, transformation tools, query 1</s>
<s id="142">XML markup increases the size of textual data signiﬁcantly.</s>
<s id="143">In the case of very large monolin- gual corpora it might be necessary to skip this additional markup and to support plain text formats as well.</s>
<s id="144">However, the disadvantage with this is that data must be handled in different ways according to the storage format and that a possible support for factors must be implemented in a different way.</s>
</p>
<p id="108">
<s id="145">D2.1— v1.1</s>
</p>
<p id="109">
<s id="146">5</s>
</p>
<p id="110">
<s id="147">Contract no.</s>
<s id="148">250456</s>
</p>
<p id="111">
<s id="149">tools, etc) are available for processing XML data efﬁciently.</s>
<s id="150">Nowadays XML can be considered to be the standard for sharing and exchanging structured information and, therefore, using XML in LetsMT! seems to be a natural choice.</s>
<s id="151">For our purposes we decided to apply a simple self-contained XML annotation without restricting ourselves to any existing XML schema or document type def- inition.</s>
<s id="152">The main reason for this is to keep our repository ﬂexible enough to be extended (for example with additional linguistic markup) without being bound to certain speciﬁcations deﬁned for other purposes.</s>
<s id="153">For LetsMT! it is not necessary to follow given standard schema’s as we are not providing data for download and sharing for other purposes than training SMT engines within our platform.</s>
<s id="154">Basically we will only require some basic markup:</s>
</p>
<p id="112">
<s id="155">• &lt;s id="..."&gt;... sentence boundaries with a unique ID within the document (not necessarily unique within the entire document collection) We use a rather loose deﬁnition of sentence here – basically sentences re- fer to the units to be used as the text fragments to be translated (or aligned) which may be list items, table cells, translation units from translation mem- ories, etc</s>
</p>
<p id="113">
<s id="156">• &lt;w&gt;...&lt;/w&gt; word/token boundaries; additional attributes (in the sense of XML tag attributes) can be added to store arbitrary features of that word that can possibly be used as a factor in SMT training</s>
</p>
<p id="114">
<s id="157">Additional markup may also be included in XML documents which might be useful for some tasks, for example, domain/style-speciﬁc sentence alignment that makes use of formatting information.</s>
<s id="158">We intentionally want to keep the schema open to allow extensions and adjustments without the need to check possible interferences with other collections.</s>
<s id="159">For SMT, we basically require to be able to extract a tok- enized and sentence aligned parallel corpus which is possible through the markup mentioned above.</s>
<s id="160">Allowing arbitrary attributes in the word boundary tags also al- lows us to add optional annotation that can be used in SMT training.</s>
<s id="161">A typical example would be to store lemmas or root forms in such attributes.</s>
<s id="162">Consider, for example, the following sample from the Europarl corpus that has been marked up in this way (see ﬁgure 1).</s>
<s id="163">In the sample from ﬁgure 1 we can see that there are four attributes for each token marked with &lt;w&gt; tags.</s>
<s id="164">Two of them contain part-of-speech tags from two different taggers (’tnt’ for the TnT tagger and ’tree’ for the TreeTagger) and one contains the lemma (also produced by the TreeTagger).</s>
<s id="165">It is now possible to use any combination of these attributes and the actual word to create the input for the training procedure (supporting factored models or not).</s>
<s id="166">There is also additional</s>
</p>
<p id="115">
<s id="167">D2.1— v1.1</s>
</p>
<p id="116">
<s id="168">6</s>
</p>
<p id="117">
<s id="169">Contract no.</s>
<s id="170">250456</s>
</p>
<p id="118">
<s id="171">&lt;s id="5"&gt; &lt;chunk type="NP" id="c-1"&gt;</s>
<s id="172">&lt;w tree="NN" tnt="NNP" lem="madam" id="w5.1"&gt;Madam&lt;/w&gt; &lt;w tree="NP" tnt="NNP" lem="President" id="w5.2"&gt;President&lt;/w&gt; &lt;/chunk&gt;</s>
<s id="173">&lt;w tree="," tnt="," lem="," id="w5.3"&gt;,&lt;/w&gt; &lt;chunk type="PP" id="c-3"&gt;</s>
<s id="174">&lt;w tree="IN" tnt="IN" lem="on" id="w5.4"&gt;on&lt;/w&gt; &lt;/chunk&gt;</s>
<s id="175">&lt;chunk type="NP" id="c-4"&gt; &lt;w tree="DT" tnt="DT" lem="a" id="w5.5"&gt;a&lt;/w&gt; &lt;w tree="NN" tnt="NN" lem="point" id="w5.6"&gt;point&lt;/w&gt; &lt;/chunk&gt;</s>
<s id="176">&lt;chunk type="SBAR" id="c-5"&gt; &lt;w tree="IN" tnt="IN" lem="of" id="w5.7"&gt;of&lt;/w&gt; &lt;/chunk&gt;</s>
<s id="177">&lt;w tree="NN" tnt="NN" lem="order" id="w5.8"&gt;order&lt;/w&gt; &lt;w tree="SENT" tnt="." lem="." id="w5.9"&gt;.&lt;/w&gt;</s>
</p>
<p id="119">
<s id="178">Figure 1: Corpus data after pre-processing.</s>
</p>
<p id="120">
<s id="179">“chunk” information that can possibly be used for other purposes or simply ignored otherwise.</s>
<s id="180">Sentences in parallel corpora need to have a unique ID within the document in order to be aligned properly to the corresponding sentences in another language as we will explain in the next section.</s>
<s id="181">Monolingual corpora will be annotated in the same way in order to match the target factors that are used in the translation model.</s>
<s id="182">Sentence IDs are not so important there as they do not have to be linked to anything else.</s>
<s id="183">However, they can still be useful to deﬁne partial selections of some corpora if necessary without reproducing data in the repository.</s>
</p>
<p id="121">
<s id="184">2.2 Alignment Information Each parallel corpus has to be aligned at the sentence level for the training proce- dures of the translation models.</s>
<s id="185">We will store links between sentences in external ﬁles pointing to the appropriate documents using the unique sentence IDs for iden- tiﬁcation of the aligned segments.</s>
<s id="186">For this we will use a simple XML format based on the XCES standard [4].</s>
<s id="187">Figure 2 illustrates a sample of such an alignment ﬁle.</s>
<s id="188">Basically, the alignment ﬁle lists links between segments in the source docu- ment (stored in the fromDoc attribute) and the target document (stored in toDoc).</s>
<s id="189">The segments are tagged with the type targType – sentences () in out case.</s>
<s id="190">Links are stored in the xtargets attribute using the unique sentence IDs in</s>
</p>
<p id="122">
<s id="191">D2.1— v1.1</s>
</p>
<p id="123">
<s id="192">7</s>
</p>
<p id="124">
<s id="193">Contract no.</s>
<s id="194">250456</s>
</p>
<p id="125">
<s id="195">&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!DOCTYPE cesAlign PUBLIC "-//CES//DTD XML cesAlign//EN" ""&gt; &lt;cesAlign version="1.0"&gt;</s>
<s id="196">&lt;linkList&gt; &lt;linkGrp targType = "s"</s>
<s id="197">fromDoc = "Europarl/xml/eng/ep-00-01-17.xml"</s>
</p>
<p id="126">
<s id="198">toDoc</s>
</p>
<p id="127">
<s id="199">= "Europarl/xml/fre/ep-00-01-17.xml"&gt;</s>
</p>
<p id="128">
<s id="200">&lt;link xtargets="1;1" /&gt; &lt;link xtargets="2;2" /&gt;</s>
<s id="201">&lt;link xtargets="3;3 4" /&gt; &lt;link xtargets="4;5" /&gt;</s>
<s id="202">&lt;link xtargets="5;6" /&gt; ...</s>
<s id="203">&lt;link xtargets="904;888" /&gt; &lt;link xtargets="905;889" /&gt; &lt;/linkGrp&gt;</s>
<s id="204">&lt;linkGrp targType = "s" fromDoc = "Europarl/xml/eng/ep-00-01-18.xml"</s>
</p>
<p id="129">
<s id="205">toDoc</s>
</p>
<p id="130">
<s id="206">= "Europarl/xml/fre/ep-00-01-18.xml"&gt;</s>
</p>
<p id="131">
<s id="207">&lt;link xtargets="1;1" /&gt; &lt;link xtargets="2;2" /&gt;</s>
<s id="208">&lt;link xtargets="3;3" /&gt;</s>
</p>
<p id="132">
<s id="209">Figure 2: Sentence alignments.</s>
</p>
<p id="133">
<s id="210">source and target document separated by one semicolon (;).</s>
<s id="211">Alignments may include multiple sentences on both sides (source and target) and may be empty as well.</s>
<s id="212">Multiple sentence IDs (sequences of sentences) are separated by one or more space characters.</s>
<s id="213">To give an example taken from ﬁgure 2: sentence 3 from document Europarl/xml/eng/ep-00-01-17.xml is aligned to sentences 3 and 4 in document Europarl/xml/fre/ep-00-01-17.xml.</s>
<s id="214">An “empty” alignment (one- to-zero link) would, for example, look like this: &lt;link xtargets="21;" /&gt;.</s>
<s id="215">Several other attributes might also be useful in sentence alignment ﬁles:</s>
</p>
<p id="134">
<s id="216">certainty: The likelihood of the given link according to some automatic align- ment procedure (attribute of the link-tag)</s>
</p>
<p id="135">
<s id="217">evaluate: Status of the alignment (attribute of the link-tag).</s>
<s id="218">In the XCES speci- ﬁcations this attribute has to be “all”, “one” or “none”.</s>
<s id="219">We might abuse this attribute to specify whether the link has been manually approved, rated or rejected in some way.</s>
</p>
<p id="136">
<s id="220">release: This is would be a non-XCES standard attribute for the linkGrp tag which we can use to specify the version or release of the corpus in the data</s>
</p>
<p id="137">
<s id="221">D2.1— v1.1</s>
</p>
<p id="138">
<s id="222">8</s>
</p>
<p id="139">
<s id="223">Contract no.</s>
<s id="224">250456</s>
</p>
<p id="140">
<s id="225">repository.</s>
<s id="226">It will be important to match the appropriate version or the corpus if we work with a revision control system and possibly different releases of the same corpus.</s>
</p>
<p id="141">
<s id="227">The ﬁle names include the path to the corpus in the data repository.</s>
<s id="228">In this way a sentence alignment ﬁle includes sufﬁcient information to check out appropriate corpora from the data repositories and to extract aligned sentences from them in the format required.</s>
<s id="229">There are several advantages of this way of storing alignment information in external ﬁles:</s>
</p>
<p id="142">
<s id="230">• All possible language pairs in multilingual parallel corpora (with more than two languages) can be aligned without repeating any of the contents of the documents.</s>
</p>
<p id="143">
<s id="231">• Sentence alignment can easily be adjusted without changing the original cor- pus annotation.</s>
</p>
<p id="144">
<s id="232">• It is easy to make selections of certain parts of a corpus or of several corpora by simply listing the links between corresponding sentences.</s>
<s id="233">For example, it is very easy to extract one-to-one sentence alignments only or at least to ignore empty alignments.</s>
<s id="234">Furthermore, a collection of parallel corpora can be assembled by simply compiling appropriate linkGrp sections into one alignment ﬁle.</s>
</p>
<p id="145">
<s id="235">• It is straightforward and space efﬁcient to store various revisions of sentence alignments.</s>
<s id="236">This can be very useful in case we want to support online align- ment using various tools or even manual inspection and modiﬁcations.</s>
</p>
<p id="146">
<s id="237">2.3 Repository Structure The LetsMT! data repository will be based on a version-controlled ﬁle system.</s>
<s id="238">We will use a simple and clear ﬁle structure to store parallel and monolingual data.</s>
<s id="239">Each corpus identiﬁed by a unique name (parallel or monolingual) will be stored in a separate version-controlled repository.</s>
<s id="240">The name of the corpus will be used as the name of this repository.</s>
<s id="241">Repositories can be created by any user but each user will only have access to his/her own branch inside this repository that will be set up during creation time.</s>
<s id="242">In this way, each user can work with a copy of existing corpora through branching (of course only if permissions allow that).</s>
<s id="243">This is space efﬁcient and ﬂexible allowing users to even apply changes to their copy without breaking data integrity.</s>
<s id="244">For each corpus the original user uploads will be</s>
</p>
<p id="147">
<s id="245">D2.1— v1.1</s>
</p>
<p id="148">
<s id="246">9</s>
</p>
<p id="149">
<s id="247">Contract no.</s>
<s id="248">250456</s>
</p>
<p id="150">
<s id="249">stored in a subdirectory raw and the pre-processed corpus ﬁles will be stored in a subdirectory xml.</s>
<s id="250">We will create subdirectories specifying the languages using ISO 639-3 language codes [5] which will contain the actual corpus ﬁles.</s>
<s id="251">Meta- information about the corpus and the tools used for conversion and pre-processing will be stored in the xml-directory (possibly in connection with a “Makeﬁle” that can be used to manage the pre-processing jobs and dependencies between certain ﬁles).</s>
<s id="252">Sentence alignments will be stored for each parallel document in the corpus using the same base name as the two linked documents.</s>
<s id="253">The alignment ﬁles will be placed in appropriate subdirectories relative to the home directory of the pre- processed data using a name composed of the two language codes (for example eng-fre for English-French).</s>
<s id="254">The entire collection of sentence alignments for each language pair within one corpus will be kept in one ﬁle in the root of the pre-processed data with a name indicating the languages that are linked (for exam- ple eng-fre.xml for the English-French sentence alignments).</s>
<s id="255">Sentence align- ments are symmetric and, therefore, only one alignment direction has to be stored.</s>
<s id="256">Here, we will use the direction with language codes in alphabetic order to be ex- plicit.</s>
<s id="257">Monolingual corpora will be saved in the same format except that no align- ment information has to be stored.</s>
<s id="258">For each corpus appropriate meta-information including domain, owner, provider, size and other statistics will be stored in a cen- tral database to make browsing the archive fast and independent of the repository contents.</s>
<s id="259">This information may be repeated for supporting archive maintenance procedures within the repository either in the header of XML documents or in ded- icated ﬁles stored together with the corpus data.</s>
<s id="260">Branching will be hidden and ﬁles will be located relative to the corpus root when checking out.</s>
<s id="261">Figure 3 shows an example of the ﬁle structure of a typical repository containing a parallel corpus (Europarl).</s>
</p>
<p id="151">
<s id="262">2.4 Revisions &amp; Corpus Selections An important feature in the LetsMT! will be the ﬂexibility of selecting data from the repository for training dedicated SMT engines.</s>
<s id="263">Selecting parallel corpora can be done by creating speciﬁc sentence alignment ﬁles that contain all the links nec- essary to specify the aligned segments to be used in training the translation model.</s>
<s id="264">These sentence alignment ﬁles can use exactly the same format as we use for the individual parallel corpora including appropriate linkGrp’s for each selected por- tion of the repository.</s>
<s id="265">A simple routine can then be used to extract the training data from the corresponding data sources in the beginning of each training procedure.</s>
<s id="266">The advantage of explicitly storing selected sentence alignments is the ﬂexibil- ity of this format.</s>
<s id="267">It is possible to combine several sources and also to combine</s>
</p>
<p id="152">
<s id="268">D2.1— v1.1</s>
</p>
<p id="153">
<s id="269">10</s>
</p>
<p id="154">
<s id="270">Contract no.</s>
<s id="271">250456</s>
</p>
<p id="155">
<s id="272">Europarl Europarl/raw/</s>
<s id="273">Europarl/raw/eng Europarl/raw/eng/ep-00-01-17.txt Europarl/raw/eng/ep-00-01-18.txt Europarl/raw/fre</s>
<s id="274">Europarl/raw/fre/ep-00-01-17.txt Europarl/raw/fre/ep-00-01-18.txt Europarl/raw/ger</s>
<s id="275">Europarl/raw/ger/ep-00-01-17.txt ...</s>
<s id="276">Europarl/xml/ Europarl/xml/eng</s>
<s id="277">Europarl/xml/eng/ep-00-01-17.xml Europarl/xml/eng/ep-00-01-18.xml Europarl/xml/fre</s>
<s id="278">Europarl/xml/fre/ep-00-01-17.xml Europarl/xml/fre/ep-00-01-18.xml Europarl/xml/ger</s>
<s id="279">Europarl/xml/ger/ep-00-01-17.xml ...</s>
<s id="280">Europarl/xml/eng-fre.xml Europarl/xml/eng-ger.xml</s>
<s id="281">Europarl/xml/fre-ger.xml Europarl/xml/eng-fre/ep-00-01-17.ces Europarl/xml/eng-fre/ep-00-01-18.ces ...</s>
<s id="282">Europarl/README Europarl/xml/README</s>
<s id="283">Europarl/xml/Makefile</s>
</p>
<p id="156">
<s id="284">Figure 3: File structure in LetsMT! repositories.</s>
</p>
<p id="157">
<s id="285">only parts of parallel corpora from the repository.</s>
<s id="286">The common user will proba- bly simply concatenate complete resources but advanced users may be interested in a more ﬁne-grained selection.</s>
<s id="287">For example, the platform may support selection certain criteria, such as, alignment type, maximum sentence length, rating or ban- ning of certain segments etc.</s>
<s id="288">Selections in form of sentence alignment ﬁles can simply be stored in the revision controlled ﬁle system with all its advantages as described above.</s>
<s id="289">Hence, corpus selections can be shared, changed, old versions can be retrieved, and so on.</s>
<s id="290">In order to store selections special revision-controlled repositories can be cre- ated with a unique name.</s>
<s id="291">In these repositories selections can be stored for each user in user-speciﬁc branches.</s>
<s id="292">Users can then decide again if they want to share</s>
</p>
<p id="158">
<s id="293">D2.1— v1.1</s>
</p>
<p id="159">
<s id="294">11</s>
</p>
<p id="160">
<s id="295">Contract no.</s>
<s id="296">250456</s>
</p>
<p id="161">
<s id="297">these selections with others or not.</s>
<s id="298">These corpus selection repositories might be a good place as well to store intermediate data from the training procedures that can be re-used (for example word alignments) and possibly also the ﬁnal models trained on that data collection.</s>
<s id="299">Selections of monolingual data for language modeling can be handled in the same way (one repository per selection with user-speciﬁc branches).</s>
<s id="300">However, the actual data selection will look differently and it does not make much sense to store a list of selected sentences for this purpose as this list will be extremely large in most cases.</s>
<s id="301">Therefore, a list of selected corpora possibly in connection with information about selection criteria would be a better choice.</s>
</p>
<p id="162">
<s id="302">3 Upload Formats Another important part of this deliverable is the speciﬁcation of upload formats which will be supported by the LetsMT! platform.</s>
<s id="303">The formats are classiﬁed in two categories: easy/complicated/risky and required/desired.</s>
<s id="304">The required formats will be prioritized from the beginning, starting with easy cases, and the desired will be included at a later stage, if possible.</s>
<s id="305">The risky formats are less likely to be perfectly processed.</s>
<s id="306">The reasons for this may vary, see comments below.</s>
<s id="307">The main difference between the easy and the complicated ﬁle formats is that the easy formats imply multilingual text that has already been sentence aligned.</s>
<s id="308">The for- mats classiﬁed as complicated are easy to extract text from, but require automatic sentence alignment which is a source of errors.</s>
<s id="309">Regarding monolingual resources, any of the supported ﬁle formats are accept- able.</s>
<s id="310">For multilingual data consisting of sets of monolingual ﬁles, a ﬁle mapping plan must be provided by the user.</s>
<s id="311">Concluding from deliverable D1.1 (requirement analysis) the main demand from potential users is concerned with pre-aligned parallel data in form of translation memories in TMX format.</s>
<s id="312">Together with our experience with the creation of par- allel corpora from various sources we will, therefore, propose the following two phases in the development of the LetsMT! platform:</s>
</p>
<p id="163">
<s id="313">1.</s>
<s id="314">Support for the upload of pre-aligned parallel corpora in required formats such as TMX and Moses/GIZA++ plain text format.</s>
<s id="315">Support of monolingual data in various formats including DOC/DOCX, PDF and possibly XML.</s>
</p>
<p id="164">
<s id="316">2.</s>
<s id="317">Support for the upload of parallel documents without explicit sentence align- ment in a few required formats (DOC/DOCX, PDF) with explicit warnings about the risks send to the user.</s>
</p>
<p id="165">
<s id="318">D2.1— v1.1</s>
</p>
<p id="166">
<s id="319">12</s>
</p>
<p id="167">
<s id="320">Contract no.</s>
<s id="321">250456</s>
</p>
<p id="168">
<s id="322">Figure 4: Classiﬁcation of upload formats.</s>
</p>
<p id="169">
<s id="323">Phase 2 may include extended support for other formats for monolingual data and may also include some experimental services such as manual inspection and cor- rection of automatic sentence alignment.</s>
<s id="324">Below we will discuss some of the issues with particular data formats that have been discussed above and in the requirement analysis of deliverable D1.1.</s>
</p>
<p id="170">
<s id="325">3.1 Pre-aligned Parallel Corpora The most important part of the data sharing facility in LetsMT! is the collection of parallel corpora that can be used for training translation models.</s>
<s id="326">The main contributions are expected to come from existing translation memories that have been collected in translation agencies or elsewhere.</s>
<s id="327">According to deliverable D1.1 the dominating exchange format is TMX (Translation Memory eXchange format).</s>
<s id="328">The next section will deal with this format.</s>
<s id="329">Other pre-aligned formats that we will support are the native plain text formats used in Giza++ and Moses, possibly even factored Moses format and maybe also XML/XCES data which is conform to the internal standards used in the LetsMT! data repository.</s>
</p>
<p id="171">
<s id="330">3.1.1 Translation Memory eXchange format (TMX) TMX is XML-compliant and, therefore, easy to transform and to convert to the in- ternal LetsMT! data format described in section 2.</s>
<s id="331">TMX speciﬁcations and ofﬁcial recommendations are available [7].</s>
<s id="332">However, we have to be aware of vendor- speciﬁc changes and modiﬁcations that do not follow existing standards (for exam- ple in the use of language codes or encoding standards).</s>
</p>
<p id="172">
<s id="333">D2.1— v1.1</s>
</p>
<p id="173">
<s id="334">13</s>
</p>
<p id="174">
<s id="335">Contract no.</s>
<s id="336">250456</s>
</p>
<p id="175">
<s id="337">Basically, TMX consist of a collection of translation units (tagged with &lt;tu&gt; elements).</s>
<s id="338">Each translation unit contains a set of translation unit variants (tagged with &lt;tuv&gt;) for each language in which this unit has been translated to.</s>
<s id="339">Appro- priate attributes specify language, encoding and other important meta-information.</s>
<s id="340">Figure 5 shows a short example (adapted from and example in [7]). &lt;?xml version="1.0"?&gt;</s>
<s id="341">&lt;!-- Example of TMX document --&gt; &lt;tmx version="1.4"&gt;</s>
<s id="342">&lt;header creationtool="XYZTool" creationtoolversion="1.01-023" datatype="PlainText"</s>
<s id="343">segtype="sentence" adminlang="en-us"</s>
<s id="344">srclang="EN" creationdate="20020101T163812Z" o-encoding="iso-8859-1" &gt;</s>
<s id="345">&lt;/header&gt; &lt;body&gt;</s>
<s id="346">&lt;tu tuid="0001" &gt; &lt;prop type="x-Domain"&gt;Computing&lt;/prop&gt; &lt;tuv xml:lang="EN"&gt;</s>
<s id="347">&lt;seg&gt;data (with a non-standard character: &amp;#xF8FF;).&lt;/seg&gt; &lt;/tuv&gt;</s>
<s id="348">&lt;tuv xml:lang="FR-CA"&gt; &lt;prop type="Origin"&gt;MT&lt;/prop&gt; &lt;seg&gt;donn&amp;#xE9;es (avec un caract&amp;#xE8;re non standard: &amp;#xF8FF;).&lt;/seg&gt;</s>
<s id="349">&lt;/tuv&gt; &lt;/tu&gt;</s>
<s id="350">&lt;tu tuid="0002"&gt; &lt;prop type="Domain"&gt;Cooking&lt;/prop&gt; &lt;tuv xml:lang="EN"&gt;&lt;seg&gt;menu&lt;/seg&gt;&lt;/tuv&gt; &lt;tuv xml:lang="FR-CA"&gt;&lt;seg&gt;menu&lt;/seg&gt;&lt;/tuv&gt; &lt;tuv xml:lang="FR-FR"&gt;&lt;seg&gt;menu&lt;/seg&gt;&lt;/tuv&gt; &lt;/tu&gt;</s>
<s id="351">&lt;/body&gt; &lt;/tmx&gt;</s>
</p>
<p id="176">
<s id="352">Figure 5: Example TMX ﬁle</s>
</p>
<p id="177">
<s id="353">TMX can be interpreted as a sentence aligned parallel corpus by simply extract- ing linked translation unit variants and treating them as aligned sentences in vari- ous languages.</s>
<s id="354">Standard stream-oriented XML parsers can be used to extract these units from arbitrary large translation memories.</s>
<s id="355">Sentence alignment ﬁles will then include one-to-one links only that refer to these extracted text fragments.</s>
<s id="356">Common</s>
</p>
<p id="178">
<s id="357">D2.1— v1.1</s>
</p>
<p id="179">
<s id="358">14</s>
</p>
<p id="180">
<s id="359">Contract no.</s>
<s id="360">250456</s>
</p>
<p id="181">
<s id="361">parsers2 should take care of encoding and special characters automatically.</s>
<s id="362">How- ever, some robustness must be added to cope with ill-formed XML input.</s>
<s id="363">This should be done in an initial validation step.</s>
<s id="364">Here, we also have to check possi- ble difference between various versions of TMX.</s>
<s id="365">Necessary restrictions regarding supported versions will be investigated in development phase of WP2.</s>
<s id="366">The largest challenge with the conversion from TMX will be the treatment of “inline” markup, i.e. content markup within text fragments that is frequently been used for formatting purposes or software speciﬁc instructions.</s>
<s id="367">Figure 6 shows two example TMX ﬁles with content markup (taken from [7]) to illustrate the complexity of this problem.</s>
</p>
<p id="182">
<s id="368">Original RTF with footnote: Elephants{\cs16\super \chftn {\footnote \pard\plain \s15\widctlpar \f4\fs20</s>
<s id="369">{\cs16\super \chftn } An elephant is a very large animal.}} are big.</s>
</p>
<p id="183">
<s id="370">TMX with content markup: Elephants&lt;ph type="fnote"&gt;{\cs16\super \chftn {\footnote \pard\plain \s15\widctlpar \f4\fs20</s>
<s id="371">{\cs16\super \chftn } &lt;sub&gt;An elephant is a very large animal.&lt;/sub&gt;}}&lt;/ph&gt; are big.</s>
</p>
<p id="184">
<s id="372">Original HTML: See the &lt;A TITLE="Go to Notes" HREF="notes.htm"&gt;Notes&lt;/A&gt; for more details.</s>
</p>
<p id="185">
<s id="373">TMX with content markup: See the &lt;bpt i="1" type="link"&gt;&amp;lt;A TITLE="&lt;sub&gt;Go to Notes&lt;/sub&gt;" HREF="notes.htm"&gt;&lt;/bpt&gt;Notes&lt;ept i="1"&gt;&amp;lt;/A&gt;&lt;/ept&gt; for more details.</s>
</p>
<p id="186">
<s id="374">Figure 6: Content markup in TMX ﬁles.</s>
</p>
<p id="187">
<s id="375">This kind of markup is important when translating documents that need to preserve formatting information and link structures.</s>
<s id="376">However, for the purpose of training it should be better ignored in order to build appropriate translation and language models.</s>
<s id="377">Looking at the examples in ﬁgure 6 this would mean that the second example will be reduced to “Go to the Notes for more details” and the link from “Notes” to 2</s>
<s id="378">We will probably use one of the open source XML parsers such as expat or libxml.</s>
</p>
<p id="188">
<s id="379">D2.1— v1.1</s>
</p>
<p id="189">
<s id="380">15</s>
</p>
<p id="190">
<s id="381">Contract no.</s>
<s id="382">250456</s>
</p>
<p id="191">
<s id="383">“notes.htm” will be stripped off.</s>
<s id="384">It would be possible to handle inline markup in the translation process by treating them as units with ﬁxed translations (for example using the XML markup allowed in the Moses decoder to create input like “Go to the &lt;inline translation="..."&gt;INLINE&lt;/inline&gt; Notes &lt;inline translation="..."&gt;INLINE&lt;/inline&gt;”).</s>
<s id="385">However, this splits the input se- quence and may prevent to match important phrase translation options such as “Go to the Notes” in the translation model.</s>
<s id="386">Additionally, the language model will also be negatively inﬂuenced by this interruption of the sequence.</s>
<s id="387">The ﬁrst example in ﬁgure 6 is a bit different.</s>
<s id="388">Here, an additional sentence is introduced as a footnote within the main sentence.</s>
<s id="389">It can be argued that the con- tents of this footnote should be extracted as additional information for the training process.</s>
<s id="390">This could be an option that we might explore treating footnote as a spe- cial case in sentence segmentation.</s>
<s id="391">However, this can be tricky in cases where proper corresponding segments cannot be found in the target language.</s>
<s id="392">For exam- ple, several footnotes may be part of one source sentence but their translations are not in the same order in the target language.</s>
<s id="393">Matching appropriate footnotes with each other is then not immediately straightforward anymore.</s>
<s id="394">Therefore, extracting these special units to obtain additional training material may do more harm than any good for the estimations of translation models.</s>
<s id="395">Anyway, we expect that we would only loose a tiny fraction of the training material when ignoring these units as well.</s>
<s id="396">We, therefore, recommend to ignore them as well but we will investigate these issues further during implementation of the pre-processing tools.</s>
<s id="397">Finally, we also want to mention that ignoring inline markup will make the ex- traction process more robust.</s>
<s id="398">The risk of breaking modules in the training pipeline (for example tokenization, tagging, conversion to Moses format possibly including factors) is high when including arbitrary markup.</s>
<s id="399">However, there are other types of placeholder markup in some localization data.</s>
<s id="400">They may refer to generic units, some kind of variables, that will be replaced by the actual contents when instantiated, for example, within a piece of software.</s>
<s id="401">These elements should not be ignored and we will investigate ways of integrating them in the pre-processing procedures to retain them in the training data.</s>
<s id="402">Another problem in the treatment of uploaded translation memories will be the handling of software-speciﬁc formatting information.</s>
<s id="403">TM systems use different methods for storing format information and it is impossible to keep track of all ways that are in use.</s>
<s id="404">For example, content markup for text in italics might be spec- iﬁed as follows: “text in {\i italics}” instead of using content markup tags such as in “text in &lt;bpt i="1" type="italic"&gt;{\i &lt;/bpt&gt; italics &lt;ept i="1"&gt;}&lt;/ept&gt;”.</s>
<s id="405">In the course of implementation these issues will be addressed in the best possible way.</s>
<s id="406">At last, we will look at possibilities to re-use meta-information that can be in-</s>
</p>
<p id="192">
<s id="407">D2.1— v1.1</s>
</p>
<p id="193">
<s id="408">16</s>
</p>
<p id="194">
<s id="409">Contract no.</s>
<s id="410">250456</s>
</p>
<p id="195">
<s id="411">ferred from the TMX documents (for example domain information, creation time, source language).</s>
<s id="412">However, as we cannot expect to ﬁnd this kind of information in all TMX uploads we will still require meta-information by the provider of the documents.</s>
</p>
<p id="196">
<s id="413">3.1.2 Plain text Giza++/Moses format Giza++ and Moses use a simple plain text format as input for word alignment and training of translation models.</s>
<s id="414">Many researchers in SMT simply work with this format when collection data as it is naively supported by the Moses toolbox.</s>
<s id="415">It is, therefore, desirable to support it in LetsMT! as well.</s>
<s id="416">Even though it will also been used in the training procedures in LetsMT! we will still convert plain text uploads to our standard internal format (see section 2).</s>
<s id="417">The Giza++/Moses format basically stores a parallel corpus in two separate text ﬁles containing the actual corpus data for source and target language, respectively.</s>
<s id="418">Files are aligned at the sentence level in such a way that corresponding sentences (or sequences of sentences) are stored at corresponding lines in the two ﬁles.</s>
<s id="419">It is, therefore, necessary that both ﬁles have exactly the same number of lines (which is easy to check) and newline characters are used to mark sentence boundaries and nothing else.</s>
<s id="420">One problem with plain text ﬁles is that there are many different possible char- acter encodings that can be used.</s>
<s id="421">It is not always possible to detect the correct en- coding automatically and, therefore, we will rely on the user’s speciﬁcations when uploading these ﬁles.</s>
<s id="422">We will assume Unicode and UTF-8 encoding as default which has to be clear to any possible user using the platform.</s>
<s id="423">Besides encoding care has to be taken about special characters.</s>
<s id="424">Some charac- ters have special meanings in Moses and have to be avoided or converted in some way.</s>
<s id="425">For example, ’_’ is used to separate factors and should not appear in plain text.</s>
<s id="426">XML markup is sometimes used to control certain behaviors of the decoder and we might need to treat those in a special way as well.</s>
<s id="427">It is also possible that certain characters can break pre-processing or the SMT training pipeline, for example, some ill-formed Unicode characters.</s>
<s id="428">All these issues are not directly a problem in the uploading phase but will also appear for other input (for example data derived from TMX) when converting to Moses format before training.</s>
<s id="429">However, special attention has to be paid to encod- ing issues to avoid crashes already in the initial step when converting uploads to the internal format.</s>
<s id="430">Hence, careful validation and robust conversion is required for plain text uploads.</s>
</p>
<p id="197">
<s id="431">D2.1— v1.1</s>
</p>
<p id="198">
<s id="432">17</s>
</p>
<p id="199">
<s id="433">Contract no.</s>
<s id="434">250456</s>
</p>
<p id="200">
<s id="435">3.1.3 Factored Moses format Moses supports also factored translation models.</s>
<s id="436">It might be useful to even support uploads that contain various factors in the plain text Moses format.</s>
<s id="437">However, this leads to many additional problems.</s>
<s id="438">Factors have to be separated by ’_’ characters and the same number of factors has to be speciﬁed for each token.</s>
<s id="439">Space charac- ters are not allowed between factors as they will be treated as a token delimiter.</s>
<s id="440">Additional ’_’ characters in the plain text that have to be converted and which are not used as factor delimiter are difﬁcult to detect.</s>
<s id="441">Factors have to be in the same order for all tokens.</s>
<s id="442">Using a factored upload assuming that annotation is correct is easy.</s>
<s id="443">Validation and detection of possible errors is tricky.</s>
<s id="444">However, simple checks rejecting ill-formed corpora are already in place in the Moses toolkit and could be integrated in LetsMT!</s>
<s id="445">However, factored uploads are not among the requested upload types and, therefore, have a lower priority.</s>
</p>
<p id="201">
<s id="446">3.1.4 XML Localization Interchange File Format (XLIFF) Another XML-based exchange format is XLIFF [8] which is mainly used for lo- calization supporting the entire process of translating localizable data to various languages.</s>
<s id="447">It borrows some of the concepts of TMX but serves a wider purpose than just storing example translations in a database.</s>
<s id="448">It allows, for example, explicit annotation of non-equivalent translations and alternative translation units.</s>
<s id="449">The gen- eral structure of an XLIFF document is shown in ﬁgure 7 (taken from [8]). &lt;xliff version=’1.2’</s>
<s id="450">xmlns=’urn:oasis:names:tc:xliff:document:1.2’&gt; &lt;file original=’hello.txt’ source-language=’en’ target-language=’fr’ datatype=’plaintext’&gt;</s>
<s id="451">&lt;body&gt; &lt;trans-unit id=’hi’&gt;</s>
<s id="452">&lt;source&gt;Hello world&lt;/source&gt; &lt;target&gt;Bonjour le monde&lt;/target&gt; &lt;alt-trans&gt;</s>
<s id="453">&lt;target xml:lang=’es’&gt;Hola mundo&lt;/target&gt; &lt;/alt-trans&gt;</s>
<s id="454">&lt;/trans-unit&gt; &lt;/body&gt;</s>
<s id="455">&lt;/file&gt; &lt;/xliff&gt;</s>
</p>
<p id="202">
<s id="456">Figure 7: The general structure of XLIFF</s>
</p>
<p id="203">
<s id="457">In LetsMT! we will be interested in the source and target contents.</s>
<s id="458">Information</s>
</p>
<p id="204">
<s id="459">D2.1— v1.1</s>
</p>
<p id="205">
<s id="460">18</s>
</p>
<p id="206">
<s id="461">Contract no.</s>
<s id="462">250456</s>
</p>
<p id="207">
<s id="463">about languages is available in the ﬁle tag or explicitly in the opening tags of source and target (using xml:lang attributes in the same way as in TMX).</s>
<s id="464">All other types of information can simply be ignored (for example, alternative translations).</s>
<s id="465">As mentioned before, XLIFF also allows to mark translations as non-equivalent, meaning that such translations are not direct translations of the source text (see ﬁg- ure 8).</s>
<s id="466">&lt;trans-unit id="t1"&gt; &lt;source&gt;Constrained text for limited&lt;/source&gt; &lt;target equiv-trans="no"&gt;Tekst angielski dla&lt;/target&gt; &lt;/trans-unit&gt;</s>
<s id="467">&lt;trans-unit id="t2"&gt; &lt;source&gt;display for English&lt;/source&gt; &lt;target equiv-trans="no"&gt;ograniczonego pola&lt;/target&gt; &lt;/trans-unit&gt;</s>
</p>
<p id="208">
<s id="468">Figure 8: Non-equivalence in XLIFF</s>
</p>
<p id="209">
<s id="469">Furthermore, there are possibilities to group translations across translation units and to add markup for segmentation.</s>
<s id="470">All these advanced techniques make it rather complex to extract appropriate units from XLIFF ﬁles.</s>
<s id="471">Therefore, it seems to be wise to ignore all these special cases and extract source and target content only when no other interfering markup can be found (see also the discussions on inline markup in section 3.1.1).</s>
<s id="472">For this standard XML parsers can be used again which will take care of encoding and special XML entities.</s>
<s id="473">Inline markup that is used in the same way as in TMX ﬁles can be treated in the same way as we do for TMX.</s>
<s id="474">According to our user study XLIFF is not on the high priority list and, therefore, it will only be added if there is growing demand on including this format.</s>
<s id="475">The format is well deﬁned and, therefore, it should not require a large effort to do so.</s>
</p>
<p id="210">
<s id="476">3.1.5 LetsMT!-conform XML/XCES The internal LetsMT! format is not a general standard that is widely used in the community.</s>
<s id="477">Even though we try to follow the XCES standard at least for the align- ment information there will be various ways of interpreting tags and attributes (for example the information stored in the xtarget attributes).</s>
<s id="478">The actual corpora can also be annotated with various types of markup.</s>
<s id="479">However, it is possible to accept a wide range of XML annotation if, at least, sentence boundaries are marked as required for our data repository and the sentence alignments.</s>
<s id="480">This can easily be veriﬁed and, as usual, standard stream-oriented XML tools can be used to process documents as needed (for example, to add tokenization markup).</s>
</p>
<p id="211">
<s id="481">D2.1— v1.1</s>
</p>
<p id="212">
<s id="482">19</s>
</p>
<p id="213">
<s id="483">Contract no.</s>
<s id="484">250456</s>
</p>
<p id="214">
<s id="485">The XML/XCES format will be used for project internal purposes only.</s>
<s id="486">There is no demand in adding this format in general as we do not expect that other users will use this type of annotation for their own data collections.</s>
</p>
<p id="215">
<s id="487">3.2 Unaligned Parallel Documents In the second phase of LetsMT! we will also support the upload of parallel doc- uments which have not been aligned at the sentence level yet.</s>
<s id="488">This implies that online alignment has to be integrated into the LetsMT! platform.</s>
<s id="489">Adding this func- tionality is a rather complex task.</s>
<s id="490">Several issues have to be considered starting from conversion and text extraction from various document formats, sentence boundary detection, tokenization and other necessary pre-processing steps up to the actual sentence alignment.</s>
<s id="491">It is planned to support various upload formats but we will concentrate on robustness in order to create reliable data resources in our platform.</s>
<s id="492">We will, therefore, only include formats for which we see the largest demand.</s>
<s id="493">Ac- cording to the requirement analysis in D1.1 this will be the DOC/DOCX formats used in Microsoft Ofﬁce (various versions), PDF and possibly plain text format with explicit speciﬁcation of character encodings.</s>
</p>
<p id="216">
<s id="494">3.2.1 Microsoft Word DOC &amp; DOCX The largest problem with MS Word ﬁles is that the DOC format is a proprietary format with no open standard speciﬁcations.</s>
<s id="495">Microsoft has the freedom to change and adjust this format as often they like and this has happened frequently in vari- ous versions of the ofﬁce package.</s>
<s id="496">Word documents include a lot of information that is difﬁcult to handle such as revisions, formatting, styles, embedded objects etc.</s>
<s id="497">However, any ﬁle format that MS Word &gt;= 2007 can open and save as struc- tured XML documents (using OpenXML) can be parsed with standard tools.</s>
<s id="498">The new XML-based DOCX formats used in recent versions of Microsoft Word is well documented in contrast to the previous proprietary solutions used by Microsoft.</s>
<s id="499">We will support those ﬁles mentioned above trying to extract plain text from the structured information.</s>
<s id="500">It will be important to instruct users who upload Word documents to inspect the results of this extraction and to warn them about the com- plications and risks when using these kind of documents.</s>
<s id="501">During the implementations restrictions with regard to versions will be in- vestigated.</s>
<s id="502">We will also investigate the use of available tools such as antiword [10] to include experimental support for older versions of Word documents.</s>
<s id="503">An- other option is Apache Tika (http://tika.apache.org/) which can handle various ﬁle formats, for example Microsoft Ofﬁce documents.</s>
<s id="504">Yet another toolkit for pro- cessing MS Word ﬁles is wvWare (http://wvware.sourceforge.net/) which is used</s>
</p>
<p id="217">
<s id="505">D2.1— v1.1</s>
</p>
<p id="218">
<s id="506">20</s>
</p>
<p id="219">
<s id="507">Contract no.</s>
<s id="508">250456</s>
</p>
<p id="220">
<s id="509">for conversion (Word import) in various word processors such as AbiWord and KWord.</s>
<s id="510">AbiWord itself can also be used for converting ﬁles on the command line.</s>
<s id="511">Converting Word documents to text could be done with a command like this: abiword --to=txt document.doc.</s>
<s id="512">Various other formats are supported, for example, rtf, utf-8, html, latex (all formats supported by AbiWord itself).</s>
<s id="513">This could be a valuable option.</s>
<s id="514">AbiWord should be rather up-to-date with recent ver- sions of Microsoft Ofﬁce and probably supports older versions as well.</s>
<s id="515">Alternatively the ofﬁcial Word Viewer from Microsoft (can be downloaded from http://www.microsoft.com/downloads) or a running instance of Word could be used in some kind of batch processing mode.</s>
<s id="516">However, it is not clear how robust such a solution would be that has to run on a separate Windows server.</s>
<s id="517">It is deﬁnitely not build to handle a queue of incoming conversion requests and a work-around might not be very stable.</s>
</p>
<p id="221">
<s id="518">3.2.2 Portable Document Format (PDF) PDF in general is hard to process.</s>
<s id="519">It was originally a proprietary format introduced by Adobe Systems but has been ofﬁcially released as an open standard in 2008 (ISO/IEC 32000-1:2008).</s>
<s id="520">Several versions are around ranging from 1.0 up to 1.7.</s>
<s id="521">PDF can be seen as a container format that may include various types of objects.</s>
<s id="522">PDF documents may include images (vector graphics and raster images), text (in- cluding information about fonts and encodings), interactive elements (forms), ﬁle attachments and meta-data.</s>
<s id="523">For LetsMT! only text objects will be interesting.</s>
<s id="524">We have to ignore PDF documents that include textual information in terms of images (scanned pages for example).</s>
<s id="525">Even extracting running text from PDF is not simple.</s>
<s id="526">Multi-line sen- tences are at risk of being separated.</s>
<s id="527">Tables, frames and pictures split the text.</s>
<s id="528">Character encodings, especially for non-western languages are problematic.</s>
<s id="529">We will present a PDF extraction solution which will be lossy and may compromise the document integrity.</s>
<s id="530">The user will be warned.</s>
<s id="531">PDF content consisting of images of scanned documents will not be processed.</s>
<s id="532">Our solution will be based on available software.</s>
<s id="533">Several PDF readers and converters are around.</s>
<s id="534">We have already experience with pdftotext which is part of the xpdf package [2].</s>
<s id="535">The tool is quite robust and supports several text encodings such as ISO-8859-1 (Latin 1), ISO-8859-2 (Latin 2 for Eastern European Languages), ISO-8859-7 (for Greek), KOI8-R (Cyrillic) and ISO-8859-8, ISO- 8859-9 (for Hebrew and Turkish).</s>
<s id="536">There is also an option ’-layout’ that can be used to maintain the physical layout of a document and in some cases this can be useful to improve segmentation tasks such as sentence boundary detection (at least from our experience).</s>
<s id="537">However, layout information may cause problems to</s>
</p>
<p id="222">
<s id="538">D2.1— v1.1</s>
</p>
<p id="223">
<s id="539">21</s>
</p>
<p id="224">
<s id="540">Contract no.</s>
<s id="541">250456</s>
</p>
<p id="225">
<s id="542">identify coherent text blocks especially in multi-column layouts.</s>
<s id="543">We did some initial experiments using simple post-processing for column detection and table conversion with quite some success.</s>
<s id="544">However, LetsMT! users who want to upload PDF documents should have the chance to adjust parameters in order to improve extraction results.</s>
<s id="545">Other tools that we will investigate for the extraction of plain text from PDF documents are listed below:</s>
</p>
<p id="226">
<s id="546">Multivalent: http://multivalent.sourceforge.net/ PDFBox: http://pdfbox.apache.org/ Tika: http://tika.apache.org/ pdftoxml: http://pdftoxml.sourceforge.net/ Poppler: http://poppler.freedesktop.org/ (GPL version of Xpdf) pdftohtml: http://pdftohtml.sourceforge.net/ pdftoword: http://www.pdftoword.com/</s>
</p>
<p id="227">
<s id="547">After the extraction of text, we will proceed with standard pre-processing in order to add sentence and token boundaries which will be necessary for the conversion to LetsMT!</s>
<s id="548">XML and the automatic sentence alignment.</s>
</p>
<p id="228">
<s id="549">3.2.3 Plain text The main problem with plain text input is the large variety of character encodings that can be used.</s>
<s id="550">Therefore, we will require explicit speciﬁcations of encodings when uploading such documents.</s>
<s id="551">This problem should not be under-estimated.</s>
<s id="552">Using the wrong settings may cause serious failures in various parts of the pipeline.</s>
<s id="553">We still need to include tools for validation and encoding detection even if users will specify the format.</s>
<s id="554">Possible problems need to be detected as early as possible.</s>
<s id="555">Many users will not know about these issues and probably need some guidance before uploading their resources.</s>
<s id="556">After validation we will process plain text with generic or language speciﬁc tools to add appropriate markup to convert ﬁles to our internal data format.</s>
<s id="557">Sen- tence alignment will be performed after the conversion.</s>
</p>
<p id="229">
<s id="558">3.2.4 Open Document Format (ODF) The Open Document Format is another XML-based ﬁle format for representing electronic documents in ofﬁce applications.</s>
<s id="559">It is used in various open source and proprietary software.</s>
<s id="560">It is even supported by Microsoft Ofﬁce 2010 and its growing popularity makes this format a good candidate to be added if the demand increases.</s>
<s id="561">The biggest advantage of ODF is that it is an open standard and speciﬁcations are</s>
</p>
<p id="230">
<s id="562">D2.1— v1.1</s>
</p>
<p id="231">
<s id="563">22</s>
</p>
<p id="232">
<s id="564">Contract no.</s>
<s id="565">250456</s>
</p>
<p id="233">
<s id="566">available [6].</s>
<s id="567">However, it still requires quite some effort to handle the complex structures of possible ODF documents correctly.</s>
</p>
<p id="234">
<s id="568">3.2.5 XML &amp; HTML Many XML-based document formats have been mentioned already.</s>
<s id="569">A general sup- port for any XML document cannot be promised as the interpretation of XML markup very much depends on the application the annotation scheme was devel- oped for.</s>
<s id="570">A generic procedure in reading character data from XML ﬁles ignoring all XML elements and attributes could be possible but might not be very useful in many cases.</s>
<s id="571">It might be more useful together with appropriate XPath expressions (provided by the user) that point at the locations within the XML documents from which the text is to be extracted.</s>
<s id="572">However, this is also of lower priority in the LetsMT! project as there does not seem to be a large demand for such a function- ality.</s>
<s id="573">With regards to HTML there is possibly a larger need to support web docu- ments in our platform.</s>
<s id="574">However, a general support of HTML is tricky.</s>
<s id="575">For well formed HTML documents without frames with explicitly and correctly stated char- acter encoding, HTML processing is not that risky.</s>
<s id="576">The general strategy will be to extract all text nodes, no matter where in the document structure they occur.</s>
<s id="577">The risky parts include missing/incorrectly declared character encodings, content in frames and by other means loaded parts from secondary sources, AJAX loaded con- tent, and more.</s>
<s id="578">Many unforeseen issues may appear and may break the LetsMT! platform.</s>
<s id="579">Several tools are available that can be used to check and cleanup HTML and XML markup.</s>
<s id="580">One option is, for example, HTML Tidy which can be down- loaded from http://tidy.sourceforge.net/.</s>
<s id="581">Other tools are Perl modules such as HTML::Laundry, HTML::Scrubber, HTML::Defang, HTML::StripScripts, HTML::Detoxiﬁer, HTML::Sanitizer (all available from CPAN) or, for example, htmlcleaner available from http://htmlcleaner.sourceforge.net/.</s>
<s id="582">Another potential candidate for our project is the robust website parser called “Beautiful Soup” which is available from http://www.crummy.com/software/BeautifulSoup/.</s>
<s id="583">We will investigate several possibilities during the development in case we want to add HTML support in the LetsMT! platform.</s>
</p>
<p id="235">
<s id="584">3.3 Monolingual Data Another part of the data repository will contain large monolingual corpora for lan- guage modeling.</s>
<s id="585">In general larger quantities of data are required and support for many ﬁle formats is necessary to obtain enough training material.</s>
<s id="586">The good thing is</s>
</p>
<p id="236">
<s id="587">D2.1— v1.1</s>
</p>
<p id="237">
<s id="588">23</s>
</p>
<p id="238">
<s id="589">Contract no.</s>
<s id="590">250456</s>
</p>
<p id="239">
<s id="591">that proper pre-processing is not as crucial as it is for parallel resources.</s>
<s id="592">This is due to the fact that no alignment has to be performed.</s>
<s id="593">For example, a few segmentation errors do not cause serious problems like they often do in parallel corpora (for ex- ample, misalignment and error propagation due to erroneous sentence boundaries).</s>
<s id="594">Furthermore, missing parts are not a serious problem either whereas incomplete documents are very difﬁcult to align.</s>
<s id="595">Therefore, it is less risky to include a wide range of ﬁle formats already in the ﬁrst phase of the project for uploading mono- lingual data.</s>
<s id="596">Basically, we will support the formats discussed above starting with the more basic and frequently used ones and then moving to more complex and less widely spread formats.</s>
<s id="597">Meta-data such as language, domain and origin will be provided by the user as usual.</s>
<s id="598">The monolingual corpora will be subjected to the same permission and sharing policy as the other repository resources.</s>
</p>
<p id="240">
<s id="599">4 Validation of Data Uploads Very important for the robustness of the system is proper validation of the data uploaded by the user.</s>
<s id="600">Data validation procedures depend very much on the data format and may include several steps.</s>
<s id="601">In general, we need to trust the input by the users when specifying the format of the documents included in any upload.</s>
<s id="602">We will require explicit speciﬁcations of all necessary parameters to identify the internal structures and formats of each upload.</s>
<s id="603">According to those parameters, validation and conversion processes will be started.</s>
<s id="604">Here, we will be as strict as possible in order to avoid any polution of our repository with noisy data sets.</s>
<s id="605">We will use standard tools and ofﬁcial speciﬁcations to carry out this task.</s>
<s id="606">One example is the conversion of translation memory ﬁles in TMX format.</s>
<s id="607">First of all, we will use validating XML parsers to check the ﬁle format (for exam- ple tools and libraries from the libxml package [3]).</s>
<s id="608">We will use the ofﬁcial DTD:s speciﬁed for the latest TMX versions to validate the markup (available from [7]).</s>
<s id="609">Byte-order markers (BOM) will be used to identify encodings.</s>
<s id="610">Validation failures will be reported through status messages in the metadata database which will be accessible from the frontend of the LetsMT platform.</s>
<s id="611">Documents that cannot be validated will not be converted and, therefore, never enter the resource database.</s>
<s id="612">Logﬁles of conversion processes will be stored in the repository in order to allow inspection of the processes that cause failures.</s>
<s id="613">Other formats will require other procedures but may re-use similar tools.</s>
<s id="614">For example XLIFF uploads will also be validated using common XML parsers but with appropriate DTD:s or XML schemas.</s>
<s id="615">Some formats will be very difﬁcult to validate because they allow such a variety of information encoded inside of the document.</s>
<s id="616">This is, for example, the case for MS Word documents, PDF ﬁles and also for plain text ﬁle formats.</s>
<s id="617">In</s>
</p>
<p id="241">
<s id="618">D2.1— v1.1</s>
</p>
<p id="242">
<s id="619">24</s>
</p>
<p id="243">
<s id="620">Contract no.</s>
<s id="621">250456</s>
</p>
<p id="244">
<s id="622">format TMX</s>
</p>
<p id="245">
<s id="623">conversion &amp; validation check BOM encoding (Perl module File::BOM) XML parsing with DTD validation (libxml, tmx.dtd) standalone XML validation without DTD for older versions of TMX conversion with our own LetsMT TMX conversion module (using standard stream-oriented XML parsers) special treatment of in-line markup (mostly ignore content)</s>
</p>
<p id="246">
<s id="624">XLIFF</s>
</p>
<p id="247">
<s id="625">check BOM encoding (Perl module File::BOM) XML parsing with XML Schema validation (libxml, xliff.xsd) standalone XML validation as backoff conversion with our own LetsMT XLIFF conversion module (us- ing standard stream-oriented XML parsers) ignore ’alternative translations’ and other markup</s>
</p>
<p id="248">
<s id="626">Text</s>
</p>
<p id="249">
<s id="627">check BOM encoding (Perl module File::BOM) possibly verify language &amp; encoding (using language identiﬁers like textcat) general validation is difﬁcult, need to trust user input</s>
</p>
<p id="250">
<s id="628">PDF</s>
</p>
<p id="251">
<s id="629">validation using pdfinfo (part of the xpdf package) conversion to text using pdftotext (also part of xpdf) typographic ligature normalizer (dedicated LetsMT module) conversion to LetsMT format via the Text module validation &amp; conversion of PDF in general is difﬁcult and error prone; users need to be warned</s>
</p>
<p id="252">
<s id="630">DOC</s>
</p>
<p id="253">
<s id="631">validation &amp; conversion to text with Apache Tika (http://tika.apache.org/) conversion to LetsMT format via the Text module validation &amp; conversion of MS Word documents is difﬁcult due to the various versions and secrets of this format; users need to be warned</s>
</p>
<p id="254">
<s id="632">Moses</s>
</p>
<p id="255">
<s id="633">validation and conversion using the Text module special module to convert alignments and reserved characters</s>
</p>
<p id="256">
<s id="634">tar/zip/gzip</s>
</p>
<p id="257">
<s id="635">validate &amp; unpack using standard GNU/Unix tools validation &amp; conversion using format speciﬁc modules</s>
</p>
<p id="258">
<s id="636">Table 1: Preliminary list of and remarks on data format speciﬁc validation and conversion tools.</s>
</p>
<p id="259">
<s id="637">D2.1— v1.1</s>
</p>
<p id="260">
<s id="638">25</s>
</p>
<p id="261">
<s id="639">Contract no.</s>
<s id="640">250456</s>
</p>
<p id="262">
<s id="641">those cases, it is impossible for automatic processes to judge whether the content is fully acceptable or not.</s>
<s id="642">This is also the case for the outcome of automatic sentence alignment processes.</s>
<s id="643">Some internally implemented heuristics will help to reduce the noise and to ﬂag possible errors in the repository.</s>
<s id="644">A preliminary list of tools that we will use for importing data is given in table 1.</s>
<s id="645">The general procedures for any data import will be the same for every data format supported.</s>
<s id="646">We will ﬁrst run validation tools on all documents.</s>
<s id="647">We proceed with conversion and data normalization if and only if the validation step succeeds.</s>
<s id="648">The status of each import will be reported in speciﬁc metadata ﬁelds that can be read by the web frontend.</s>
<s id="649">It is also important to mention that validation and con- version processes will be run as off-line processes that will not block the system otherwise.</s>
<s id="650">The web frontend has to take care of the task to inform the user about val- idation and conversion errors.</s>
<s id="651">Note, that documents that could not be validated or converted correctly do not enter the repository and, therefore, do not pollute the data collection.</s>
<s id="652">Important is also that users are aware of possible problems and conversion limitations.</s>
<s id="653">This is another task for the interface developed for interacting with LetsMT users.</s>
<s id="654">In many cases it will be difﬁcult to automatically detect errors especially if we allow uploads of arbitrary languages.</s>
<s id="655">Here, again, the web frontend has to enable possibilities to inspect conversion results (at least some snapshots) in order to give users the opportunity to improve or remove noisy content.</s>
</p>
<p id="263">
<s id="656">5 Risk Analysis In this document we discuss our plans for the data sharing facilities in LetsMT!</s>
<s id="657">The formats mentioned and described will guide us in the development of the plat- form.</s>
<s id="658">There will be the need to adjust these goals due to unforeseen problems and changes but also according to new developments and opportunities that have been discovered in the course of implementation.</s>
<s id="659">We tried to outline risks already in the introduction and discussed the need for a priority list especially with respect to upload formats.</s>
<s id="660">The most important task for the data sharing facilities is to pro- vide a robust and fast interface to the data repository.</s>
<s id="661">We, therefore, propose to concentrate on a few well supported formats ﬁrst before adding further formats to the platform.</s>
<s id="662">In this way users will not be disappointed as often by broken and buggy processes and we do not have to count with heavy maintenance tasks when running the system.</s>
<s id="663">Another important point is that users have to be aware of possible problems when uploading data in various formats.</s>
<s id="664">It is necessary to warn them about possible</s>
</p>
<p id="264">
<s id="665">D2.1— v1.1</s>
</p>
<p id="265">
<s id="666">26</s>
</p>
<p id="266">
<s id="667">Contract no.</s>
<s id="668">250456</s>
</p>
<p id="267">
<s id="669">risks and to give them the opportunity to inspect conversion results and to inﬂuence the upload and pre-processing steps.</s>
<s id="670">It is crucial to include validation tools for all formats supported and to check all aspects of a user upload in order to identify possible problems and to give feedback in case of detected errors.</s>
<s id="671">Another big risk is the possibility of attacks and damage caused by hackers.</s>
<s id="672">Even though we require user authentication we will not be free of such attacks and we have to be aware of risks that certain ﬁle formats bear when we allow arbitrary uploads.</s>
<s id="673">This has to be carefully investigated during implementation and testing.</s>
</p>
<p id="268">
<s id="674">6 Conclusions The success of LetsMT! crucially depends on the data sharing facilities that we will build during the project.</s>
<s id="675">In this deliverable we specify the internal data formats and the structure of the data repository.</s>
<s id="676">We will use a uniﬁed format for corpus data and sentence alignment which will be organized in a version-controlled ﬁle system.</s>
<s id="677">Data uploads will be supported in a variety of formats.</s>
<s id="678">The implementation will be done in two phases:</s>
</p>
<p id="269">
<s id="679">Phase 1: Support for uploading pre-aligned parallel corpora in standard formats (TMX, Moses format) and for uploading monolingual data in popular for- mats (DOC, PDF, plain text).</s>
<s id="680">Experimental support for other formats for uploads of monolingual data.</s>
<s id="681">This will enable us to analyze the risks in including them in phase 2 even for parallel data uploads.</s>
</p>
<p id="270">
<s id="682">Phase 2: Support for uploading unaligned parallel documents in a few popular formats (DOC, PDF, plain text).</s>
<s id="683">Online sentence alignment and possibilities to inspect intermediate results (after conversion, pre-processing, alignment) and possibilities to inﬂuence these processing steps (adjusting parameters, selecting alternative tools that have been integrated in LetsMT!).</s>
<s id="684">Start: M10</s>
</p>
<p id="271">
<s id="685">Data sharing facilities will be reﬁned until the end of the project.</s>
<s id="686">Additional pre- processing tools will be included and the robustness of the system will be im- proved.</s>
<s id="687">Support of additional formats will also be added as time permits.</s>
</p>
<p id="272">
<s id="688">D2.1— v1.1</s>
</p>
<p id="273">
<s id="689">27</s>
</p>
<p id="274">
<s id="690">Contract no.</s>
<s id="691">250456</s>
</p>
<p id="275">
<s id="692">References [1] Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, Francois ¸</s>
<s id="693">Yergeau, and John Cowan.</s>
<s id="694">Extensible Markup Language (XML) 1.1.</s>
<s id="695">Tex- tuality and Netscape, Microsoft, W3C &amp; Sun Microsystems, Inc., 2006. http://www.w3.org/standards/xml/ and http://www.w3.org/TR/xml11.</s>
</p>
<p id="276">
<s id="696">[2] foolabs.</s>
</p>
<p id="277">
<s id="697">Xpdf - a toolkit for viewing and processing pdf documents.</s>
</p>
<p id="278">
<s id="698">http://www.foolabs.com/xpdf/.</s>
</p>
<p id="279">
<s id="699">[3] Gnome.</s>
</p>
<p id="280">
<s id="700">libxml – the xml c parser and toolkit of gnome.</s>
</p>
<p id="281">
<s id="701">http://www.xmlsoft.org/, 2011.</s>
</p>
<p id="282">
<s id="702">[4] Nancy Ide, Keith Suderman, and Laurent Romary.</s>
<s id="703">XCES – Corpus Encoding Standard for XML.</s>
<s id="704">Department of Computer Science, Vassar College, Pough- keepsie NY, USA &amp; Equipe Langue et Dialogue LORIA/CNRS, Vandoeuvre- l` s-Nancy FRANCE, 2008. http://www.xces.org/. e</s>
</p>
<p id="283">
<s id="705">[5] ISO 639-3:2007 – Codes for the representation of names of languages – Part 3: Alpha-3 code for comprehensive coverage of languages, 2007. http://www.iso.org/iso/iso catalogue/catalogue tc/catalogue detail.htm?csnumber=39534, http://www.sil.org/iso639-3/.</s>
</p>
<p id="284">
<s id="706">[6] OASIS.</s>
</p>
<p id="285">
<s id="707">OpenDocument</s>
</p>
<p id="286">
<s id="708">v1.0</s>
</p>
<p id="287">
<s id="709">speciﬁcation.</s>
</p>
<p id="288">
<s id="710">http://www.oasis-</s>
</p>
<p id="289">
<s id="711">open.org/committees/download.php/12572/OpenDocument-v1.0-os.pdf.</s>
</p>
<p id="290">
<s id="712">[7] Yves Savoure.</s>
</p>
<p id="291">
<s id="713">TMX 1.4b Speciﬁcation – OSCAR Recommen-</s>
</p>
<p id="292">
<s id="714">dation.</s>
</p>
<p id="293">
<s id="715">The Localisation Industry Standards Association, 2005.</s>
</p>
<p id="294">
<s id="716">http://www.lisa.org/tmx/tmx.htm.</s>
</p>
<p id="295">
<s id="717">[8] Yves Savourel, John Reid, Tony Jewtushenko, and Rodolfo M.</s>
</p>
<p id="296">
<s id="718">Raya.</s>
</p>
<p id="297">
<s id="719">XLIFF Version 1.2 – OASIS Standard.</s>
</p>
<p id="298">
<s id="720">Organization for</s>
</p>
<p id="299">
<s id="721">the Advancement of Structured Information Standards (OASIS), 2008. http://docs.oasis-open.org/xliff/xliff-core/xliff-core.html.</s>
</p>
<p id="300">
<s id="722">[9] Unicode, Inc.</s>
<s id="723">The Unicode Standard: A Technical Introduction, 2010. http://www.unicode.org/standard/principles.html.</s>
</p>
<p id="301">
<s id="724">[10] Adri van Os.</s>
</p>
<p id="302">
<s id="725">On MS Word document readers (antiword), 2008.</s>
</p>
<p id="303">
<s id="726">http://www.winfield.demon.nl/.</s>
</p>
<p id="304">
<s id="727">D2.1— v1.1</s>
</p>
<p id="305">
<s id="728">28</s>
</p>
</body>
</letsmt>
