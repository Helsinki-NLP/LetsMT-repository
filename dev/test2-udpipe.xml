<?xml version="1.0" encoding="utf-8"?>
<letsmt version="1.0">
<s id="1">LetsMT!</s>
<s id="2">Platform for Online Sharing of Training Data and Building User Tailored MT www.letsmt.eu/ Project no.</s>
<s id="3">250456 Deliverable D2.1 Specification of data formats Version No. v1.1 May 25, 2011 1 Contract no.</s>
<s id="4">250456</s>
<s id="5">Document Information Deliverable number:</s>
<s id="6">Deliverable title:</s>
<s id="7">Due date of deliverable according to DoW: D2.1 Specification of data formats</s>
<s id="8">31/08/2010 Actual submission date of deliverable:</s>
<s id="9">31/08/2010 Main Author(s): Participants: Reviewer Workpackage: Workpackage title:</s>
<s id="10">J¨org Tiedemann, Per Weijnitz Uppsala Tilde, Moravia WP2 SMT resource repository and data processing facili- ties Workpackage leader: Dissemination Level:</s>
<s id="11">Version:</s>
<s id="12">Keywords: Uppsala PU v1.1 data formats Version History Version Date Status Name of Au- thor (Partner) Contribu- tions Description/ Approval Level v0.1 July 17, 2010 initial draft Uppsala ready for re- viewing v0.2 August 17, 2010 final draft Uppsala v1.0 August 30, 2010 final version Uppsala approved by all partners v1.1 May 23, 2011 revised version Uppsala EXECUTIVE SUMMARY</s>
<s id="13">This is a description of data formats that will be used internally in the LetsMT!</s>
<s id="14">data resource repository and data formats that will be allowed when uploading parallel and monolingual data to the LetsMT! platform.</s>
<s id="15">The report includes a discussion of issues that have to be handled for various formats and points to solutions and tools that will be used in the project.</s>
<s id="16">D2.1— v1.1 2 Contract no.</s>
<s id="17">250456</s>
<s id="18">Contents 1 Task Description 5 2 Internal Storage Formats 2.1 Corpus Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</s>
<s id="19">2.2 Alignment Information . . . . . . . . . . . . . . . . . . . . . . .</s>
<s id="20">2.3 Repository Structure . . . . . . . . . . . . . . . . . . . . . . . . 5 5 7 9 2 .4 Revisions &amp; Corpus Selections . . . . . . . . . . . . . . . . . . .</s>
<s id="21">10 3 Upload Formats</s>
<s id="22">3.1 Pre-aligned Parallel Corpora . . . . . . . . . . . . . . . . . . . . 3.1.1 Translation Memory eXchange format (TMX) . . . . . . 3.1.2 Plain text Giza++/Moses format . . . . . . . . . . . . . . 3.1.3 Factored Moses format . . . . . . . . . . . . . . . . . . . 3.1.4 XML Localization Interchange File Format (XLIFF) . . . 3.1.5 LetsMT!-conform XML/XCES . . . . . . . . . . . . . .</s>
<s id="23">3.2 Unaligned Parallel Documents . . . . . . . . . . . . . . . . . . . 3.2.1 Microsoft Word DOC &amp; DOCX . . . . . . . . . . . . . .</s>
<s id="24">3.2.2 Portable Document Format (PDF) . . . . . . . . . . . . . 3.2.3 Plain text . . . . . . . . . . . . . . . . . . . . . . . . . .</s>
<s id="25">3.2.4 Open Document Format (ODF) . . . . . . . . . . . . . . 3.2.5 XML &amp; HTML . . . . . . . . . . . . . . . . . . . . . . . 3.3 Monolingual Data . . . . . . . . . . . . . . . . . . . . . . . . . . 12 13 13 17 18 18 19 20 20 21 22 22 23 23 4 Validation of Data Uploads</s>
<s id="26">24 5 Risk Analysis</s>
<s id="27">26 6 Conclusions 27 D2.1— v1.1 3 Contract no.</s>
<s id="28">250456</s>
<s id="29">List of Figures 1 Corpus data after pre-processing . . . . . . . . . . . . . . . . . . . 7 2 Sentence alignments . . . . . . . . . . . . . . . . . . . . . . . . . 8 3 4 5 6 File structure in LetsMT!</s>
<s id="30">repositories Classification of upload formats. . . Example TMX file . . . . . . . . . .</s>
<s id="31">Content markup in TMX files. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</s>
<s id="32">11 13 14 15 7 8 The general structure of Non-equivalence in XLIFF XLIFF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 19 List of Tables 1 Preliminary list of and remarks on data format specific validation and conversion tools. . . . . . . . . . . . . . . . . . . . . . . . . 25 D2.1— v1.1 4 Contract no.</s>
<s id="33">250456</s>
<s id="34">1 Task Description</s>
<s id="35">One of the key functions of the LetsMT!</s>
<s id="36">platform is to provide the possibility to train domain specific SMT models tailored towards specific needs of its users.</s>
<s id="37">For this appropriate data resources are required.</s>
<s id="38">LetsMT!</s>
<s id="39">is based on data sharing and user collaboration.</s>
<s id="40">The scope of workpackage two is to develop facilities to store, process and manage resources coming from LetsMT!</s>
<s id="41">users.</s>
<s id="42">The purpose of this report is to specify data formats that will be used internally when storing parallel and monolingual corpus data in the repository and to list data formats that will be supported for the user contributions.</s>
<s id="43">The main focus here is to balance robustness and flexibility, meaning that supported upload formats have to be handled in a sta- ble and robust way.</s>
<s id="44">Each additional formats usually increases complexity of the validation and conversion processes and, therefore, may reduce overall robustness of the system.</s>
<s id="45">Restricting the system to a few well supported formats will lead to user satisfaction more than a brittle system with a lot of possibilities would do.</s>
<s id="46">Adding support for new formats can always be done later on after carefully test- ing the integration of upload possibilities and after checking possible interferences with existing features.</s>
<s id="47">2 Internal Storage Formats</s>
<s id="48">In this section we will describe the internal data formats that we will use to store training data in the shared repository.</s>
<s id="49">We will use a unified format for all textual data in the repository which makes it easy to select subsets of the entire collection for training tailored SMT engines.</s>
<s id="50">All incoming data will be converted to this format and possibly enriched using pre-processing tools.</s>
<s id="51">We will also store the raw uploads to ensure data recovery and to make it possible to adjust conversion and pre-processing if necessary.</s>
<s id="52">2.1 Corpus</s>
<s id="53">Data</s>
<s id="54">All corpus data, regardless whether it is part of a parallel corpus or part of a mono- lingual corpus, will be stored in a simple XML format.1 XML is a well-established and widely used markup language for the representation of structured information.</s>
<s id="55">XML comes with fixed standard specifications [1], naively supports Unicode [9], and the main advantage is that a lot of tools (parsers, transformation tools, query 1 XML markup increases the size of textual data significantly.</s>
<s id="56">In the case of very large monolin- gual corpora it might be necessary to skip this additional markup and to support plain text formats as well.</s>
<s id="57">However, the disadvantage with this is that data must be handled in different ways according to the storage format and that a possible support for factors must be implemented in a different way.</s>
<s id="58">D2.1— v1.1 5 Contract no.</s>
<s id="59">250456 tools, etc) are available for processing XML data efficiently.</s>
<s id="60">Nowadays XML can be considered to be the standard for sharing and exchanging structured information and, therefore, using XML in LetsMT!</s>
<s id="61">seems to be a natural choice.</s>
<s id="62">For our purposes we decided to apply a simple self-contained XML annotation without restricting ourselves to any existing XML schema or document type def- inition.</s>
<s id="63">The main reason for this is to keep our repository flexible enough to be extended (for example with additional linguistic markup) without being bound to certain specifications defined for other purposes.</s>
<s id="64">For LetsMT!</s>
<s id="65">it is not necessary to follow given standard schema’s as we are not providing data for download and sharing for other purposes than training SMT engines within our platform.</s>
<s id="66">Basically we will only require some basic markup: •</s>
<s id="67">&lt;s id="..."&gt;... sentence boundaries with a unique ID within the document (not necessarily unique within the entire document collection)</s>
<s id="68">We use a rather loose definition of sentence here – basically sentences re- fer to the units to be used as the text fragments to be translated (or aligned) which may be list items, table cells, translation units from translation mem- ories, etc •</s>
<s id="69">&lt;w&gt;...&lt;/w&gt; word/token boundaries; additional attributes (in the sense of XML tag attributes) can be added to store arbitrary features of that word that can possibly be used as a factor in SMT training Additional markup may also be included in XML documents which might be useful for some tasks, for example, domain/style-specific sentence alignment that makes use of formatting information.</s>
<s id="70">We intentionally want to keep the schema open to allow extensions and adjustments without the need to check possible interferences with other collections.</s>
<s id="71">For SMT, we basically require to be able to extract a tok- enized and sentence aligned parallel corpus which is possible through the markup mentioned above.</s>
<s id="72">Allowing arbitrary attributes in the word boundary tags also al- lows us to add optional annotation that can be used in SMT training.</s>
<s id="73">A typical example would be to store lemmas or root forms in such attributes.</s>
<s id="74">Consider, for example, the following sample from the Europarl corpus that has been marked up in this way (see figure 1).</s>
<s id="75">In the sample from figure 1 we can see that there are four attributes for each token marked with &lt;w&gt; tags.</s>
<s id="76">Two of them contain part-of-speech tags from two different taggers (’tnt’ for the TnT tagger and ’tree’ for the TreeTagger) and one contains the lemma (also produced by the TreeTagger).</s>
<s id="77">It is now possible to use any combination of these attributes and the actual word to create the input for the training procedure (supporting factored models or not).</s>
<s id="78">There is also additional D2.1— v1.1 6 Contract no.</s>
<s id="79">250456</s>
<s id="80">&lt;s id="5"&gt; &lt;chunk type="NP" id="c-1"&gt; &lt;w tree="NN" tnt="NNP" lem="madam" id="w5.1"&gt;Madam&lt;/w&gt;</s>
<s id="81">&lt;w tree="NP" tnt="NNP" lem="President" id="w5.2"&gt;President&lt;/w&gt; &lt;/chunk&gt; &lt;w tree="," tnt="," lem="," id="w5.3"&gt;,&lt;/w&gt; &lt;chunk type="PP" id="c-3"&gt; &lt;w tree="IN" tnt="IN" lem="on" id="w5.4"&gt;on&lt;/w&gt; &lt;/chunk&gt; &lt;chunk type="NP" id="c-4"&gt; &lt;w tree="DT" tnt="DT" lem="a" id="w5.5"&gt;a&lt;/w&gt;</s>
<s id="82">&lt;w tree="NN" tnt="NN" lem="point" id="w5.6"&gt;point&lt;/w&gt; &lt;/chunk&gt; &lt;chunk type="SBAR" id="c-5"&gt; &lt;w tree="IN" tnt="IN" lem="of" id="w5.7"&gt;of&lt;/w&gt;</s>
<s id="83">&lt;/chunk&gt; &lt;w tree="NN" tnt="NN" lem="order" id="w5.8"&gt;order&lt;/w&gt; &lt;w tree="SENT" tnt="." lem="." id="w5.9"&gt;.&lt;/w&gt;</s>
<s id="84">Figure 1: Corpus data after pre-processing.</s>
<s id="85">“chunk” information that can possibly be used for other purposes or simply ignored otherwise.</s>
<s id="86">Sentences in parallel corpora need to have a unique ID within the document in order to be aligned properly to the corresponding sentences in another language as we will explain in the next section.</s>
<s id="87">Monolingual corpora will be annotated in the same way in order to match the target factors that are used in the translation model.</s>
<s id="88">Sentence IDs are not so important there as they do not have to be linked to anything else.</s>
<s id="89">However, they can still be useful to define partial selections of some corpora if necessary without reproducing data in the repository.</s>
<s id="90">2.2 Alignment Information</s>
<s id="91">Each parallel corpus has to be aligned at the sentence level for the training proce- dures of the translation models.</s>
<s id="92">We will store links between sentences in external files pointing to the appropriate documents using the unique sentence IDs for iden- tification of the aligned segments.</s>
<s id="93">For this we will use a simple XML format based on the XCES standard [4].</s>
<s id="94">Figure 2 illustrates a sample of such an alignment file.</s>
<s id="95">Basically, the alignment file lists links between segments in the source docu- ment (stored in the fromDoc attribute) and the target document (stored in toDoc).</s>
<s id="96">The segments are tagged with the type targType – sentences () in out case.</s>
<s id="97">Links are stored in the xtargets attribute using the unique sentence IDs in D2.1— v1.1 7 Contract no.</s>
<s id="98">250456</s>
<s id="99">&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!DOCTYPE cesAlign PUBLIC "-//CES//DTD XML cesAlign//EN" ""&gt; &lt;cesAlign version="1.0"&gt; &lt;linkList&gt; &lt;linkGrp targType = "s" fromDoc = "Europarl/xml/eng/ep-00-01-17.xml" toDoc = "Europarl/xml/fre/ep-00-01-17.xml"&gt;</s>
<s id="100">&lt;link xtargets="1;1" /&gt; &lt;link xtargets="2;2" /&gt; &lt;link xtargets="3;3</s>
<s id="101">4" /&gt; &lt;link xtargets="4;5"</s>
<s id="102">/&gt; &lt;link xtargets="5;6" /&gt; ... &lt;link xtargets="904;888" /&gt; &lt;link xtargets="905;889" /&gt; &lt;/linkGrp&gt; &lt;linkGrp targType = "s" fromDoc = "Europarl/xml/eng/ep-00-01-18.xml" toDoc = "Europarl/xml/fre/ep-00-01-18.xml"&gt;</s>
<s id="103">&lt;link xtargets="1;1" /&gt; &lt;link xtargets="2;2" /&gt; &lt;link xtargets="3;3" /&gt; Figure 2:</s>
<s id="104">Sentence alignments.</s>
<s id="105">source and target document separated by one semicolon (;).</s>
<s id="106">Alignments may include multiple sentences on both sides (source and target) and may be empty as well.</s>
<s id="107">Multiple sentence IDs (sequences of sentences) are separated by one or more space characters.</s>
<s id="108">To give an example taken from figure 2: sentence 3 from document Europarl/xml/eng/ep-00-01-17.xml is aligned to sentences 3 and 4 in document Europarl/xml/fre/ep-00-01-17.xml.</s>
<s id="109">An “empty” alignment (one- to-zero link) would, for example, look like this: &lt;link xtargets="21;" /&gt;.</s>
<s id="110">Several other attributes might also be useful in sentence alignment files: certainty:</s>
<s id="111">The likelihood of the given link according to some automatic align- ment procedure (attribute of the link-tag) evaluate: Status of the alignment (attribute of the link-tag).</s>
<s id="112">In the XCES speci- fications this attribute has to be “all”, “one” or “none”.</s>
<s id="113">We might abuse this attribute to specify whether the link has been manually approved, rated or rejected in some way.</s>
<s id="114">release: This is would be a non-XCES standard attribute for the linkGrp tag which we can use to specify the version or release of the corpus in the data D2.1— v1.1 8 Contract no.</s>
<s id="115">250456 repository.</s>
<s id="116">It will be important to match the appropriate version or the corpus if we work with a revision control system and possibly different releases of the same corpus.</s>
<s id="117">The file names include the path to the corpus in the data repository.</s>
<s id="118">In this way a sentence alignment file includes sufficient information to check out appropriate corpora from the data repositories and to extract aligned sentences from them in the format required.</s>
<s id="119">There are several advantages of this way of storing alignment information in external files: •</s>
<s id="120">All possible language pairs in multilingual parallel corpora (with more than two languages) can be aligned without repeating any of the contents of the documents. •</s>
<s id="121">Sentence alignment can easily be adjusted without changing the original cor- pus annotation.</s>
<s id="122">•</s>
<s id="123">It is easy to make selections of certain parts of a corpus or of several corpora by simply listing the links between corresponding sentences.</s>
<s id="124">For example, it is very easy to extract one-to-one sentence alignments only or at least to ignore empty alignments.</s>
<s id="125">Furthermore, a collection of parallel corpora can be assembled by simply compiling appropriate linkGrp sections into one alignment file. •</s>
<s id="126">It is straightforward and space efficient to store various revisions of sentence alignments.</s>
<s id="127">This can be very useful in case we want to support online align- ment using various tools or even manual inspection and modifications.</s>
<s id="128">2.3 Repository Structure</s>
<s id="129">The LetsMT!</s>
<s id="130">data repository will be based on a version-controlled file system.</s>
<s id="131">We will use a simple and clear file structure to store parallel and monolingual data.</s>
<s id="132">Each corpus identified by a unique name (parallel or monolingual) will be stored in a separate version-controlled repository.</s>
<s id="133">The name of the corpus will be used as the name of this repository.</s>
<s id="134">Repositories can be created by any user but each user will only have access to his/her own branch inside this repository that will be set up during creation time.</s>
<s id="135">In this way, each user can work with a copy of existing corpora through branching (of course only if permissions allow that).</s>
<s id="136">This is space efficient and flexible allowing users to even apply changes to their copy without breaking data integrity.</s>
<s id="137">For each corpus the original user uploads will be D2.1— v1.1 9 Contract no.</s>
<s id="138">250456 stored in a subdirectory raw and the pre-processed corpus files will be stored in a subdirectory xml.</s>
<s id="139">We will create subdirectories specifying the languages using ISO 639-3 language codes [5] which will contain the actual corpus files.</s>
<s id="140">Meta- information about the corpus and the tools used for conversion and pre-processing will be stored in the xml-directory (possibly in connection with a “Makefile” that can be used to manage the pre-processing jobs and dependencies between certain files).</s>
<s id="141">Sentence alignments will be stored for each parallel document in the corpus using the same base name as the two linked documents.</s>
<s id="142">The alignment files will be placed in appropriate subdirectories relative to the home directory of the pre- processed data using a name composed of the two language codes (for example eng-fre for English-French).</s>
<s id="143">The entire collection of sentence alignments for each language pair within one corpus will be kept in one file in the root of the pre-processed data with a name indicating the languages that are linked (for exam- ple eng-fre.xml for the English-French sentence alignments).</s>
<s id="144">Sentence align- ments are symmetric and, therefore, only one alignment direction has to be stored.</s>
<s id="145">Here, we will use the direction with language codes in alphabetic order to be ex- plicit.</s>
<s id="146">Monolingual corpora will be saved in the same format except that no align- ment information has to be stored.</s>
<s id="147">For each corpus appropriate meta-information including domain, owner, provider, size and other statistics will be stored in a cen- tral database to make browsing the archive fast and independent of the repository contents.</s>
<s id="148">This information may be repeated for supporting archive maintenance procedures within the repository either in the header of XML documents or in ded- icated files stored together with the corpus data.</s>
<s id="149">Branching will be hidden and files will be located relative to the corpus root when checking out.</s>
<s id="150">Figure 3 shows an example of the file structure of a typical repository containing a parallel corpus (Europarl).</s>
<s id="151">2.4 Revisions &amp; Corpus Selections</s>
<s id="152">An important feature in the LetsMT!</s>
<s id="153">will be the flexibility of selecting data from the repository for training dedicated SMT engines.</s>
<s id="154">Selecting parallel corpora can be done by creating specific sentence alignment files that contain all the links nec- essary to specify the aligned segments to be used in training the translation model.</s>
<s id="155">These sentence alignment files can use exactly the same format as we use for the individual parallel corpora including appropriate linkGrp’s for each selected por- tion of the repository.</s>
<s id="156">A simple routine can then be used to extract the training data from the corresponding data sources in the beginning of each training procedure.</s>
<s id="157">The advantage of explicitly storing selected sentence alignments is the flexibil- ity of this format.</s>
<s id="158">It is possible to combine several sources and also to combine D2.1— v1.1 10 Contract no.</s>
<s id="159">250456</s>
<s id="160">Europarl Europarl/raw/ Europarl/raw/eng Europarl/raw/eng/ep-00-01-17.txt</s>
<s id="161">Europarl/raw/eng/ep-00-01-18.txt</s>
<s id="162">Europarl/raw/fre Europarl/raw/fre/ep-00-01-17.txt</s>
<s id="163">Europarl/raw/fre/ep-00-01-18.txt</s>
<s id="164">Europarl/raw/ger Europarl/raw/ger/ep-00-01-17.txt</s>
<s id="165">...</s>
<s id="166">Europarl/xml/ Europarl/xml/eng Europarl/xml/eng/ep-00-01-17.xml</s>
<s id="167">Europarl/xml/eng/ep-00-01-18.xml</s>
<s id="168">Europarl/xml/fre Europarl/xml/fre/ep-00-01-17.xml</s>
<s id="169">Europarl/xml/fre/ep-00-01-18.xml</s>
<s id="170">Europarl/xml/ger</s>
<s id="171">Europarl/xml/ger/ep-00-01-17.xml</s>
<s id="172">...</s>
<s id="173">Europarl/xml/eng-fre.xml</s>
<s id="174">Europarl/xml/eng-ger.xml</s>
<s id="175">Europarl/xml/fre-ger.xml Europarl/xml/eng-fre/ep-00-01-17.ces</s>
<s id="176">Europarl/xml/eng-fre/ep-00-01-18.ces</s>
<s id="177">...</s>
<s id="178">Europarl/README</s>
<s id="179">Europarl/xml/README</s>
<s id="180">Europarl/xml/Makefile</s>
<s id="181">Figure 3: File structure in LetsMT!</s>
<s id="182">repositories.</s>
<s id="183">only parts of parallel corpora from the repository.</s>
<s id="184">The common user will proba- bly simply concatenate complete resources but advanced users may be interested in a more fine-grained selection.</s>
<s id="185">For example, the platform may support selection certain criteria, such as, alignment type, maximum sentence length, rating or ban- ning of certain segments etc.</s>
<s id="186">Selections in form of sentence alignment files can simply be stored in the revision controlled file system with all its advantages as described above.</s>
<s id="187">Hence, corpus selections can be shared, changed, old versions can be retrieved, and so on.</s>
<s id="188">In order to store selections special revision-controlled repositories can be cre- ated with a unique name.</s>
<s id="189">In these repositories selections can be stored for each user in user-specific branches.</s>
<s id="190">Users can then decide again if they want to share D2.1— v1.1 11 Contract no.</s>
<s id="191">250456</s>
<s id="192">these selections with others or not.</s>
<s id="193">These corpus selection repositories might be a good place as well to store intermediate data from the training procedures that can be re-used (for example word alignments) and possibly also the final models trained on that data collection.</s>
<s id="194">Selections of monolingual data for language modeling can be handled in the same way (one repository per selection with user-specific branches).</s>
<s id="195">However, the actual data selection will look differently and it does not make much sense to store a list of selected sentences for this purpose as this list will be extremely large in most cases.</s>
<s id="196">Therefore, a list of selected corpora possibly in connection with information about selection criteria would be a better choice.</s>
<s id="197">3 Upload Formats</s>
<s id="198">Another important part of this deliverable is the specification of upload formats which will be supported by the LetsMT!</s>
<s id="199">platform.</s>
<s id="200">The formats are classified in two categories: easy/complicated/risky and required/desired.</s>
<s id="201">The required formats will be prioritized from the beginning, starting with easy cases, and the desired will be included at a later stage, if possible.</s>
<s id="202">The risky formats are less likely to be perfectly processed.</s>
<s id="203">The reasons for this may vary, see comments below.</s>
<s id="204">The main difference between the easy and the complicated file formats is that the easy formats imply multilingual text that has already been sentence aligned.</s>
<s id="205">The for- mats classified as complicated are easy to extract text from, but require automatic sentence alignment which is a source of errors.</s>
<s id="206">Regarding monolingual resources, any of the supported file formats are accept- able.</s>
<s id="207">For multilingual data consisting of sets of monolingual files, a file mapping plan must be provided by the user.</s>
<s id="208">Concluding from deliverable D1.1 (requirement analysis) the main demand from potential users is concerned with pre-aligned parallel data in form of translation memories in TMX format.</s>
<s id="209">Together with our experience with the creation of par- allel corpora from various sources we will, therefore, propose the following two phases in the development of the LetsMT!</s>
<s id="210">platform:</s>
<s id="211">1.</s>
<s id="212">Support for the upload of pre-aligned parallel corpora in required formats such as TMX and Moses/GIZA++ plain text format.</s>
<s id="213">Support of monolingual data in various formats including DOC/DOCX, PDF and possibly XML.</s>
<s id="214">2.</s>
<s id="215">Support for the upload of parallel documents without explicit sentence align- ment in a few required formats (DOC/DOCX, PDF) with explicit warnings about the risks send to the user.</s>
<s id="216">D2.1— v1.1 12 Contract no.</s>
<s id="217">250456</s>
<s id="218">Figure 4: Classification of upload formats.</s>
<s id="219">Phase 2 may include extended support for other formats for monolingual data and may also include some experimental services such as manual inspection and cor- rection of automatic sentence alignment.</s>
<s id="220">Below we will discuss some of the issues with particular data formats that have been discussed above and in the requirement analysis of deliverable D1.1.</s>
<s id="221">3.1 Pre-aligned Parallel Corpora</s>
<s id="222">The most important part of the data sharing facility in LetsMT!</s>
<s id="223">is the collection of parallel corpora that can be used for training translation models.</s>
<s id="224">The main contributions are expected to come from existing translation memories that have been collected in translation agencies or elsewhere.</s>
<s id="225">According to deliverable D1.1 the dominating exchange format is TMX (Translation Memory eXchange format).</s>
<s id="226">The next section will deal with this format.</s>
<s id="227">Other pre-aligned formats that we will support are the native plain text formats used in Giza++ and Moses, possibly even factored Moses format and maybe also XML/XCES data which is conform to the internal standards used in the LetsMT!</s>
<s id="228">data repository.</s>
<s id="229">3.1.1 Translation Memory eXchange format (TMX)</s>
<s id="230">TMX is XML-compliant and, therefore, easy to transform and to convert to the in- ternal LetsMT!</s>
<s id="231">data format described in section 2. TMX specifications and official recommendations are available [7].</s>
<s id="232">However, we have to be aware of vendor- specific changes and modifications that do not follow existing standards (for exam- ple in the use of language codes or encoding standards).</s>
<s id="233">D2.1— v1.1 13 Contract no.</s>
<s id="234">250456</s>
<s id="235">Basically, TMX consist of a collection of translation units (tagged with &lt;tu&gt; elements).</s>
<s id="236">Each translation unit contains a set of translation unit variants (tagged with &lt;tuv&gt;) for each language in which this unit has been translated to.</s>
<s id="237">Appro- priate attributes specify language, encoding and other important meta-information.</s>
<s id="238">Figure 5 shows a short example (adapted from and example in [7]).</s>
<s id="239">&lt;?xml version="1.0"?&gt;</s>
<s id="240">&lt;!--</s>
<s id="241">Example of TMX document --&gt; &lt;tmx version="1.4"&gt; &lt;header creationtool="XYZTool" creationtoolversion="1.01-023" datatype="PlainText" segtype="sentence" adminlang="en-us" srclang="EN" creationdate="20020101T163812Z" o-encoding="iso-8859-</s>
<s id="242">1" &gt; &lt;/header&gt; &lt;body&gt; &lt;tu tuid="0001" &gt; &lt;prop type="x-Domain"&gt;</s>
<s id="243">Computing&lt;/prop&gt; &lt;tuv xml:lang="EN"&gt;</s>
<s id="244">&lt;seg&gt;data (with a non-standard character: &amp;#xF8FF;).&lt;/seg&gt; &lt;/tuv&gt; &lt;tuv xml:lang="FR-CA"&gt; &lt;prop type="Origin"&gt;MT&lt;/prop&gt; &lt;seg&gt;donn&amp;#xE9;es (avec un caract&amp;#xE8;re non standard: &amp;#xF8FF;).&lt;/seg&gt; &lt;/tuv&gt; &lt;/tu&gt; &lt;tu tuid="0002"&gt; &lt;prop type="Domain"&gt;</s>
<s id="245">Cooking&lt;/prop&gt; &lt;tuv xml:lang="EN"&gt;&lt;seg&gt;menu&lt;/seg&gt;&lt;/tuv&gt; &lt;tuv xml:lang="FR-CA"&gt;&lt;seg&gt;menu&lt;/seg&gt;&lt;/tuv&gt; &lt;tuv xml:lang="FR-FR"&gt;&lt;seg&gt;menu&lt;/seg&gt;&lt;/tuv&gt; &lt;/tu&gt; &lt;/body&gt; &lt;/tmx&gt; Figure 5: Example TMX file TMX can be interpreted as a sentence aligned parallel corpus by simply extract- ing linked translation unit variants and treating them as aligned sentences in vari- ous languages.</s>
<s id="246">Standard stream-oriented XML parsers can be used to extract these units from arbitrary large translation memories.</s>
<s id="247">Sentence alignment files will then include one-to-one links only that refer to these extracted text fragments.</s>
<s id="248">Common D2.1— v1.1 14 Contract no.</s>
<s id="249">250456 parsers2 should take care of encoding and special characters automatically.</s>
<s id="250">How- ever, some robustness must be added to cope with ill-formed XML input.</s>
<s id="251">This should be done in an initial validation step.</s>
<s id="252">Here, we also have to check possi- ble difference between various versions of TMX.</s>
<s id="253">Necessary restrictions regarding supported versions will be investigated in development phase of WP2.</s>
<s id="254">The largest challenge with the conversion from TMX will be the treatment of “inline” markup, i.e. content markup within text fragments that is frequently been used for formatting purposes or software specific instructions.</s>
<s id="255">Figure 6 shows two example TMX files with content markup (taken from [7]) to illustrate the complexity of this problem.</s>
<s id="256">Original RTF with footnote:</s>
<s id="257">Elephants{\cs16\super \chftn {\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super \chftn }</s>
<s id="258">An elephant is a very large animal.}}</s>
<s id="259">are big.</s>
<s id="260">TMX with content markup:</s>
<s id="261">Elephants&lt;ph type="fnote"&gt;{\cs16\super \chftn {\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super \chftn }</s>
<s id="262">&lt;sub&gt;An elephant is a very large animal.&lt;/sub&gt;}}&lt;/ph&gt;</s>
<s id="263">are big.</s>
<s id="264">Original HTML: See the &lt;A TITLE="Go to Notes" HREF="notes.htm"&gt;Notes&lt;/A&gt; for more details.</s>
<s id="265">TMX with content markup:</s>
<s id="266">See the &lt;bpt i="1" type="link"&gt;&amp;lt;A TITLE="&lt;sub&gt;Go to Notes&lt;/sub&gt;" HREF="notes.htm"&gt;&lt;/bpt&gt;Notes&lt;ept i="1"&gt;&amp;lt;/A&gt;&lt;/ept&gt; for more details.</s>
<s id="267">Figure 6: Content markup in TMX files.</s>
<s id="268">This kind of markup is important when translating documents that need to preserve formatting information and link structures.</s>
<s id="269">However, for the purpose of training it should be better ignored in order to build appropriate translation and language models.</s>
<s id="270">Looking at the examples in figure 6 this would mean that the second example will be reduced to “Go to the Notes for more details” and the link from “Notes” to 2 We will probably use one of the open source XML parsers such as expat or libxml.</s>
<s id="271">D2.1— v1.1 15 Contract no.</s>
<s id="272">250456 “notes.htm” will be stripped off.</s>
<s id="273">It would be possible to handle inline markup in the translation process by treating them as units with fixed translations (for example using the XML markup allowed in the Moses decoder to create input like “Go to the &lt;inline translation="..."&gt;INLINE&lt;/inline&gt;</s>
<s id="274">Notes &lt;inline translation="..."&gt;INLINE&lt;/inline&gt;”).</s>
<s id="275">However, this splits the input se- quence and may prevent to match important phrase translation options such as “Go to the Notes” in the translation model.</s>
<s id="276">Additionally, the language model will also be negatively influenced by this interruption of the sequence.</s>
<s id="277">The first example in figure 6 is a bit different.</s>
<s id="278">Here, an additional sentence is introduced as a footnote within the main sentence.</s>
<s id="279">It can be argued that the con- tents of this footnote should be extracted as additional information for the training process.</s>
<s id="280">This could be an option that we might explore treating footnote as a spe- cial case in sentence segmentation.</s>
<s id="281">However, this can be tricky in cases where proper corresponding segments cannot be found in the target language.</s>
<s id="282">For exam- ple, several footnotes may be part of one source sentence but their translations are not in the same order in the target language.</s>
<s id="283">Matching appropriate footnotes with each other is then not immediately straightforward anymore.</s>
<s id="284">Therefore, extracting these special units to obtain additional training material may do more harm than any good for the estimations of translation models.</s>
<s id="285">Anyway, we expect that we would only loose a tiny fraction of the training material when ignoring these units as well.</s>
<s id="286">We, therefore, recommend to ignore them as well but we will investigate these issues further during implementation of the pre-processing tools.</s>
<s id="287">Finally, we also want to mention that ignoring inline markup will make the ex- traction process more robust.</s>
<s id="288">The risk of breaking modules in the training pipeline (for example tokenization, tagging, conversion to Moses format possibly including factors) is high when including arbitrary markup.</s>
<s id="289">However, there are other types of placeholder markup in some localization data.</s>
<s id="290">They may refer to generic units, some kind of variables, that will be replaced by the actual contents when instantiated, for example, within a piece of software.</s>
<s id="291">These elements should not be ignored and we will investigate ways of integrating them in the pre-processing procedures to retain them in the training data.</s>
<s id="292">Another problem in the treatment of uploaded translation memories will be the handling of software-specific formatting information.</s>
<s id="293">TM systems use different methods for storing format information and it is impossible to keep track of all ways that are in use.</s>
<s id="294">For example, content markup for text in italics might be spec- ified as follows:</s>
<s id="295">“text in {\i italics}” instead of using content markup tags such as in “text in &lt;bpt i="1" type="italic"&gt;{\i &lt;/bpt&gt; italics &lt;ept i="1"&gt;}&lt;/ept&gt;”.</s>
<s id="296">In the course of implementation these issues will be addressed in the best possible way.</s>
<s id="297">At last, we will look at possibilities to re-use meta-information that can be in- D2.1— v1.1 16 Contract no.</s>
<s id="298">250456 ferred from the TMX documents (for example domain information, creation time, source language).</s>
<s id="299">However, as we cannot expect to find this kind of information in all TMX uploads we will still require meta-information by the provider of the documents.</s>
<s id="300">3.1.2 Plain text Giza++/Moses format Giza++ and Moses use a simple plain text format as input for word alignment and training of translation models.</s>
<s id="301">Many researchers in SMT simply work with this format when collection data as it is naively supported by the Moses toolbox.</s>
<s id="302">It is, therefore, desirable to support it in LetsMT!</s>
<s id="303">as well.</s>
<s id="304">Even though it will also been used in the training procedures in LetsMT!</s>
<s id="305">we will still convert plain text uploads to our standard internal format (see section 2).</s>
<s id="306">The Giza++/Moses format basically stores a parallel corpus in two separate text files containing the actual corpus data for source and target language, respectively.</s>
<s id="307">Files are aligned at the sentence level in such a way that corresponding sentences (or sequences of sentences) are stored at corresponding lines in the two files.</s>
<s id="308">It is, therefore, necessary that both files have exactly the same number of lines (which is easy to check) and newline characters are used to mark sentence boundaries and nothing else.</s>
<s id="309">One problem with plain text files is that there are many different possible char- acter encodings that can be used.</s>
<s id="310">It is not always possible to detect the correct en- coding automatically and, therefore, we will rely on the user’s specifications when uploading these files.</s>
<s id="311">We will assume Unicode and UTF-8 encoding as default which has to be clear to any possible user using the platform.</s>
<s id="312">Besides encoding care has to be taken about special characters.</s>
<s id="313">Some charac- ters have special meanings in Moses and have to be avoided or converted in some way.</s>
<s id="314">For example, ’_’ is used to separate factors and should not appear in plain text.</s>
<s id="315">XML markup is sometimes used to control certain behaviors of the decoder and we might need to treat those in a special way as well.</s>
<s id="316">It is also possible that certain characters can break pre-processing or the SMT training pipeline, for example, some ill-formed Unicode characters.</s>
<s id="317">All these issues are not directly a problem in the uploading phase but will also appear for other input (for example data derived from TMX) when converting to Moses format before training.</s>
<s id="318">However, special attention has to be paid to encod- ing issues to avoid crashes already in the initial step when converting uploads to the internal format.</s>
<s id="319">Hence, careful validation and robust conversion is required for plain text uploads.</s>
<s id="320">D2.1— v1.1 17 Contract no.</s>
<s id="321">250456 3.1.3 Factored Moses format</s>
<s id="322">Moses supports also factored translation models.</s>
<s id="323">It might be useful to even support uploads that contain various factors in the plain text Moses format.</s>
<s id="324">However, this leads to many additional problems.</s>
<s id="325">Factors have to be separated by ’_’ characters and the same number of factors has to be specified for each token.</s>
<s id="326">Space charac- ters are not allowed between factors as they will be treated as a token delimiter.</s>
<s id="327">Additional ’_’ characters in the plain text that have to be converted and which are not used as factor delimiter are difficult to detect.</s>
<s id="328">Factors have to be in the same order for all tokens.</s>
<s id="329">Using a factored upload assuming that annotation is correct is easy.</s>
<s id="330">Validation and detection of possible errors is tricky.</s>
<s id="331">However, simple checks rejecting ill-formed corpora are already in place in the Moses toolkit and could be integrated in LetsMT!</s>
<s id="332">However, factored uploads are not among the requested upload types and, therefore, have a lower priority.</s>
<s id="333">3.1.4 XML Localization Interchange File Format (XLIFF) Another XML-based exchange format is XLIFF [8] which is mainly used for lo- calization supporting the entire process of translating localizable data to various languages.</s>
<s id="334">It borrows some of the concepts of TMX but serves a wider purpose than just storing example translations in a database.</s>
<s id="335">It allows, for example, explicit annotation of non-equivalent translations and alternative translation units.</s>
<s id="336">The gen- eral structure of an XLIFF document is shown in figure 7 (taken from [8]).</s>
<s id="337">&lt;xliff version=’1.2’ xmlns=’urn:oasis:names:tc:xliff:document:1.2’&gt; &lt;file original=’hello.txt’ source-language=’en’ target-language=’fr’ datatype=’plaintext’&gt; &lt;body&gt; &lt;trans-unit id=’hi’&gt; &lt;source&gt;Hello world&lt;/source&gt; &lt;target&gt;Bonjour le monde&lt;/target&gt; &lt;alt-trans&gt; &lt;target xml:lang=’es’&gt;</s>
<s id="338">Hola mundo&lt;/target&gt; &lt;/alt-trans&gt; &lt;/trans-unit&gt; &lt;/body&gt; &lt;/file&gt; &lt;/xliff&gt;</s>
<s id="339">Figure 7: The general structure of XLIFF In LetsMT!</s>
<s id="340">we will be interested in the source and target contents.</s>
<s id="341">Information D2.1— v1.1 18 Contract no.</s>
<s id="342">250456 about languages is available in the file tag or explicitly in the opening tags of source and target (using xml:lang attributes in the same way as in TMX).</s>
<s id="343">All other types of information can simply be ignored (for example, alternative translations).</s>
<s id="344">As mentioned before, XLIFF also allows to mark translations as non-equivalent, meaning that such translations are not direct translations of the source text (see fig- ure 8).</s>
<s id="345">&lt;trans-unit id="t1"&gt; &lt;source&gt;Constrained text for limited&lt;/source&gt; &lt;target equiv-trans="no"&gt;Tekst angielski dla&lt;/target&gt; &lt;/trans-unit&gt; &lt;trans-unit id="t2"&gt; &lt;source&gt;display for English&lt;/source&gt; &lt;target equiv-trans="no"&gt;ograniczonego pola&lt;/target&gt;</s>
<s id="346">&lt;/trans-unit&gt;</s>
<s id="347">Figure 8: Non-equivalence in XLIFF</s>
<s id="348">Furthermore, there are possibilities to group translations across translation units and to add markup for segmentation.</s>
<s id="349">All these advanced techniques make it rather complex to extract appropriate units from XLIFF files.</s>
<s id="350">Therefore, it seems to be wise to ignore all these special cases and extract source and target content only when no other interfering markup can be found (see also the discussions on inline markup in section 3.1.1).</s>
<s id="351">For this standard XML parsers can be used again which will take care of encoding and special XML entities.</s>
<s id="352">Inline markup that is used in the same way as in TMX files can be treated in the same way as we do for TMX.</s>
<s id="353">According to our user study XLIFF is not on the high priority list and, therefore, it will only be added if there is growing demand on including this format.</s>
<s id="354">The format is well defined and, therefore, it should not require a large effort to do so.</s>
<s id="355">3.1.5 LetsMT!-conform XML/XCES</s>
<s id="356">The internal LetsMT!</s>
<s id="357">format is not a general standard that is widely used in the community.</s>
<s id="358">Even though we try to follow the XCES standard at least for the align- ment information there will be various ways of interpreting tags and attributes (for example the information stored in the xtarget attributes).</s>
<s id="359">The actual corpora can also be annotated with various types of markup.</s>
<s id="360">However, it is possible to accept a wide range of XML annotation if, at least, sentence boundaries are marked as required for our data repository and the sentence alignments.</s>
<s id="361">This can easily be verified and, as usual, standard stream-oriented XML tools can be used to process documents as needed (for example, to add tokenization markup).</s>
<s id="362">D2.1— v1.1 19 Contract no.</s>
<s id="363">250456</s>
<s id="364">The XML/XCES format will be used for project internal purposes only.</s>
<s id="365">There is no demand in adding this format in general as we do not expect that other users will use this type of annotation for their own data collections.</s>
<s id="366">3.2 Unaligned Parallel Documents</s>
<s id="367">In the second phase of LetsMT!</s>
<s id="368">we will also support the upload of parallel doc- uments which have not been aligned at the sentence level yet.</s>
<s id="369">This implies that online alignment has to be integrated into the LetsMT!</s>
<s id="370">platform.</s>
<s id="371">Adding this func- tionality is a rather complex task.</s>
<s id="372">Several issues have to be considered starting from conversion and text extraction from various document formats, sentence boundary detection, tokenization and other necessary pre-processing steps up to the actual sentence alignment.</s>
<s id="373">It is planned to support various upload formats but we will concentrate on robustness in order to create reliable data resources in our platform.</s>
<s id="374">We will, therefore, only include formats for which we see the largest demand.</s>
<s id="375">Ac- cording to the requirement analysis in D1.1 this will be the DOC/DOCX formats used in Microsoft Office (various versions), PDF and possibly plain text format with explicit specification of character encodings.</s>
<s id="376">3.2.1 Microsoft Word DOC &amp; DOCX</s>
<s id="377">The largest problem with MS Word files is that the DOC format is a proprietary format with no open standard specifications.</s>
<s id="378">Microsoft has the freedom to change and adjust this format as often they like and this has happened frequently in vari- ous versions of the office package.</s>
<s id="379">Word documents include a lot of information that is difficult to handle such as revisions, formatting, styles, embedded objects etc.</s>
<s id="380">However, any file format that MS Word &gt;= 2007 can open and save as struc- tured XML documents (using OpenXML) can be parsed with standard tools.</s>
<s id="381">The new XML-based DOCX formats used in recent versions of Microsoft Word is well documented in contrast to the previous proprietary solutions used by Microsoft.</s>
<s id="382">We will support those files mentioned above trying to extract plain text from the structured information.</s>
<s id="383">It will be important to instruct users who upload</s>
<s id="384">Word documents to inspect the results of this extraction and to warn them about the com- plications and risks when using these kind of documents.</s>
<s id="385">During the implementations restrictions with regard to versions will be in- vestigated.</s>
<s id="386">We will also investigate the use of available tools such as antiword [10] to include experimental support for older versions of Word documents.</s>
<s id="387">An- other option is Apache Tika (http://tika.apache.org/) which can handle various file formats, for example Microsoft Office documents.</s>
<s id="388">Yet another toolkit for pro- cessing MS Word files is wvWare (http://wvware.sourceforge.net/) which is used D2.1— v1.1 20 Contract no.</s>
<s id="389">250456 for conversion (Word import) in various word processors such as AbiWord and KWord.</s>
<s id="390">AbiWord itself can also be used for converting files on the command line.</s>
<s id="391">Converting</s>
<s id="392">Word documents to text could be done with a command like this: abiword --to=txt document.doc.</s>
<s id="393">Various other formats are supported, for example, rtf, utf-8, html, latex (all formats supported by AbiWord itself).</s>
<s id="394">This could be a valuable option.</s>
<s id="395">AbiWord should be rather up-to-date with recent ver- sions of Microsoft Office and probably supports older versions as well.</s>
<s id="396">Alternatively the official Word Viewer from Microsoft (can be downloaded from</s>
<s id="397">http://www.microsoft.com/downloads) or a running instance of Word could be used in some kind of batch processing mode.</s>
<s id="398">However, it is not clear how robust such a solution would be that has to run on a separate Windows server.</s>
<s id="399">It is definitely not build to handle a queue of incoming conversion requests and a work-around might not be very stable.</s>
<s id="400">3.2.2 Portable Document Format (PDF) PDF in general is hard to process.</s>
<s id="401">It was originally a proprietary format introduced by Adobe Systems but has been officially released as an open standard in 2008 (ISO/IEC 32000-1:2008).</s>
<s id="402">Several versions are around ranging from 1.0 up to 1.7.</s>
<s id="403">PDF can be seen as a container format that may include various types of objects.</s>
<s id="404">PDF documents may include images (vector graphics and raster images), text (in- cluding information about fonts and encodings), interactive elements (forms), file attachments and meta-data.</s>
<s id="405">For LetsMT!</s>
<s id="406">only text objects will be interesting.</s>
<s id="407">We have to ignore PDF documents that include textual information in terms of images (scanned pages for example).</s>
<s id="408">Even extracting running text from PDF is not simple.</s>
<s id="409">Multi-line sen- tences are at risk of being separated.</s>
<s id="410">Tables, frames and pictures split the text.</s>
<s id="411">Character encodings, especially for non-western languages are problematic.</s>
<s id="412">We will present a PDF extraction solution which will be lossy and may compromise the document integrity.</s>
<s id="413">The user will be warned.</s>
<s id="414">PDF content consisting of images of scanned documents will not be processed.</s>
<s id="415">Our solution will be based on available software.</s>
<s id="416">Several PDF readers and converters are around.</s>
<s id="417">We have already experience with pdftotext which is part of the xpdf package [2].</s>
<s id="418">The tool is quite robust and supports several text encodings such as ISO-8859-1 (Latin 1), ISO-8859-2 (Latin 2 for Eastern European Languages), ISO-8859-7 (for Greek), KOI8-R (Cyrillic) and ISO-8859-8, ISO- 8859-9 (for Hebrew and Turkish).</s>
<s id="419">There is also an option ’-layout’ that can be used to maintain the physical layout of a document and in some cases this can be useful to improve segmentation tasks such as sentence boundary detection (at least from our experience).</s>
<s id="420">However, layout information may cause problems to D2.1— v1.1 21 Contract no.</s>
<s id="421">250456 identify coherent text blocks especially in multi-column layouts.</s>
<s id="422">We did some initial experiments using simple post-processing for column detection and table conversion with quite some success.</s>
<s id="423">However, LetsMT!</s>
<s id="424">users who want to upload PDF documents should have the chance to adjust parameters in order to improve extraction results.</s>
<s id="425">Other tools that we will investigate for the extraction of plain text from PDF documents are listed below:</s>
<s id="426">Multivalent: http://multivalent.sourceforge.net/ PDFBox: http://pdfbox.apache.org/ Tika: http://tika.apache.org/ pdftoxml: http://pdftoxml.sourceforge.net/ Poppler: http://poppler.freedesktop.org/ (GPL version of Xpdf) pdftohtml: http://pdftohtml.sourceforge.net/ pdftoword: http://www.pdftoword.com/ After the extraction of text, we will proceed with standard pre-processing in order to add sentence and token boundaries which will be necessary for the conversion to LetsMT!</s>
<s id="427">XML and the automatic sentence alignment.</s>
<s id="428">3.2.3 Plain text</s>
<s id="429">The main problem with plain text input is the large variety of character encodings that can be used.</s>
<s id="430">Therefore, we will require explicit specifications of encodings when uploading such documents.</s>
<s id="431">This problem should not be under-estimated.</s>
<s id="432">Using the wrong settings may cause serious failures in various parts of the pipeline.</s>
<s id="433">We still need to include tools for validation and encoding detection even if users will specify the format.</s>
<s id="434">Possible problems need to be detected as early as possible.</s>
<s id="435">Many users will not know about these issues and probably need some guidance before uploading their resources.</s>
<s id="436">After validation we will process plain text with generic or language specific tools to add appropriate markup to convert files to our internal data format.</s>
<s id="437">Sen- tence alignment will be performed after the conversion.</s>
<s id="438">3.2.4 Open Document Format (ODF) The Open Document Format is another XML-based file format for representing electronic documents in office applications.</s>
<s id="439">It is used in various open source and proprietary software.</s>
<s id="440">It is even supported by Microsoft Office 2010 and its growing popularity makes this format a good candidate to be added if the demand increases.</s>
<s id="441">The biggest advantage of ODF is that it is an open standard and specifications are D2.1— v1.1 22 Contract no.</s>
<s id="442">250456 available [6].</s>
<s id="443">However, it still requires quite some effort to handle the complex structures of possible ODF documents correctly.</s>
<s id="444">3.2.5 XML &amp; HTML Many XML-based document formats have been mentioned already.</s>
<s id="445">A general sup- port for any XML document cannot be promised as the interpretation of XML markup very much depends on the application the annotation scheme was devel- oped for.</s>
<s id="446">A generic procedure in reading character data from XML files ignoring all XML elements and attributes could be possible but might not be very useful in many cases.</s>
<s id="447">It might be more useful together with appropriate XPath expressions (provided by the user) that point at the locations within the XML documents from which the text is to be extracted.</s>
<s id="448">However, this is also of lower priority in the LetsMT!</s>
<s id="449">project as there does not seem to be a large demand for such a function- ality.</s>
<s id="450">With regards to HTML there is possibly a larger need to support web docu- ments in our platform.</s>
<s id="451">However, a general support of HTML is tricky.</s>
<s id="452">For well formed HTML documents without frames with explicitly and correctly stated char- acter encoding, HTML processing is not that risky.</s>
<s id="453">The general strategy will be to extract all text nodes, no matter where in the document structure they occur.</s>
<s id="454">The risky parts include missing/incorrectly declared character encodings, content in frames and by other means loaded parts from secondary sources, AJAX loaded con- tent, and more.</s>
<s id="455">Many unforeseen issues may appear and may break the LetsMT!</s>
<s id="456">platform.</s>
<s id="457">Several tools are available that can be used to check and cleanup HTML and XML markup.</s>
<s id="458">One option is, for example, HTML Tidy which can be down- loaded from http://tidy.sourceforge.net/.</s>
<s id="459">Other tools are Perl modules such as HTML::Laundry, HTML::Scrubber, HTML::Defang, HTML::StripScripts, HTML::Detoxifier, HTML::Sanitizer (all available from CPAN) or, for example, htmlcleaner available from http://htmlcleaner.sourceforge.net/.</s>
<s id="460">Another potential candidate for our project is the robust website parser called “Beautiful Soup” which is available from</s>
<s id="461">http://www.crummy.com/software/BeautifulSoup/.</s>
<s id="462">We will investigate several possibilities during the development in case we want to add HTML support in the LetsMT!</s>
<s id="463">platform.</s>
<s id="464">3.3 Monolingual Data</s>
<s id="465">Another part of the data repository will contain large monolingual corpora for lan- guage modeling.</s>
<s id="466">In general larger quantities of data are required and support for many file formats is necessary to obtain enough training material.</s>
<s id="467">The good thing is D2.1— v1.1 23 Contract no.</s>
<s id="468">250456 that proper pre-processing is not as crucial as it is for parallel resources.</s>
<s id="469">This is due to the fact that no alignment has to be performed.</s>
<s id="470">For example, a few segmentation errors do not cause serious problems like they often do in parallel corpora (for ex- ample, misalignment and error propagation due to erroneous sentence boundaries).</s>
<s id="471">Furthermore, missing parts are not a serious problem either whereas incomplete documents are very difficult to align.</s>
<s id="472">Therefore, it is less risky to include a wide range of file formats already in the first phase of the project for uploading mono- lingual data.</s>
<s id="473">Basically, we will support the formats discussed above starting with the more basic and frequently used ones and then moving to more complex and less widely spread formats.</s>
<s id="474">Meta-data such as language, domain and origin will be provided by the user as usual.</s>
<s id="475">The monolingual corpora will be subjected to the same permission and sharing policy as the other repository resources.</s>
<s id="476">4 Validation of Data Uploads</s>
<s id="477">Very important for the robustness of the system is proper validation of the data uploaded by the user.</s>
<s id="478">Data validation procedures depend very much on the data format and may include several steps.</s>
<s id="479">In general, we need to trust the input by the users when specifying the format of the documents included in any upload.</s>
<s id="480">We will require explicit specifications of all necessary parameters to identify the internal structures and formats of each upload.</s>
<s id="481">According to those parameters, validation and conversion processes will be started.</s>
<s id="482">Here, we will be as strict as possible in order to avoid any polution of our repository with noisy data sets.</s>
<s id="483">We will use standard tools and official specifications to carry out this task.</s>
<s id="484">One example is the conversion of translation memory files in TMX format.</s>
<s id="485">First of all, we will use validating XML parsers to check the file format (for exam- ple tools and libraries from the libxml package [3]).</s>
<s id="486">We will use the official DTD:s specified for the latest TMX versions to validate the markup (available from [7]).</s>
<s id="487">Byte-order markers (BOM) will be used to identify encodings.</s>
<s id="488">Validation failures will be reported through status messages in the metadata database which will be accessible from the frontend of the LetsMT platform.</s>
<s id="489">Documents that cannot be validated will not be converted and, therefore, never enter the resource database.</s>
<s id="490">Logfiles of conversion processes will be stored in the repository in order to allow inspection of the processes that cause failures.</s>
<s id="491">Other formats will require other procedures but may re-use similar tools.</s>
<s id="492">For example XLIFF uploads will also be validated using common XML parsers but with appropriate DTD:s or XML schemas.</s>
<s id="493">Some formats will be very difficult to validate because they allow such a variety of information encoded inside of the document.</s>
<s id="494">This is, for example, the case for MS Word documents, PDF files and also for plain text file formats.</s>
<s id="495">In D2.1— v1.1 24 Contract no.</s>
<s id="496">250456 format TMX conversion &amp; validation check BOM encoding (Perl module File::BOM) XML parsing with DTD validation (libxml, tmx.dtd) standalone XML validation without DTD for older versions of TMX conversion with our own LetsMT TMX conversion module (using standard stream-oriented XML parsers) special treatment of in-line markup (mostly ignore content) XLIFF check BOM encoding (Perl module File::BOM) XML parsing with XML Schema validation (libxml, xliff.xsd) standalone XML validation as backoff conversion with our own LetsMT XLIFF conversion module (us- ing standard stream-oriented XML parsers) ignore ’alternative translations’ and other markup</s>
<s id="497">Text check BOM encoding (Perl module File::BOM) possibly verify language &amp; encoding (using language identifiers like textcat) general validation is difficult, need to trust user input PDF validation using pdfinfo (part of the xpdf package) conversion to text using pdftotext (also part of xpdf) typographic ligature normalizer (dedicated LetsMT module) conversion to LetsMT format via the Text module validation &amp; conversion of PDF in general is difficult and error prone; users need to be warned DOC validation &amp; conversion to text with Apache Tika (http://tika.apache.org/) conversion to LetsMT format via the Text module validation &amp; conversion of MS Word documents is difficult due to the various versions and secrets of this format; users need to be warned Moses validation and conversion using the Text module special module to convert alignments and reserved characters tar/zip/gzip validate &amp; unpack using standard GNU/Unix tools validation &amp; conversion using format specific modules Table 1: Preliminary list of and remarks on data format specific validation and conversion tools.</s>
<s id="498">D2.1— v1.1 25 Contract no.</s>
<s id="499">250456</s>
<s id="500">those cases, it is impossible for automatic processes to judge whether the content is fully acceptable or not.</s>
<s id="501">This is also the case for the outcome of automatic sentence alignment processes.</s>
<s id="502">Some internally implemented heuristics will help to reduce the noise and to flag possible errors in the repository.</s>
<s id="503">A preliminary list of tools that we will use for importing data is given in table 1.</s>
<s id="504">The general procedures for any data import will be the same for every data format supported.</s>
<s id="505">We will first run validation tools on all documents.</s>
<s id="506">We proceed with conversion and data normalization if and only if the validation step succeeds.</s>
<s id="507">The status of each import will be reported in specific metadata fields that can be read by the web frontend.</s>
<s id="508">It is also important to mention that validation and con- version processes will be run as off-line processes that will not block the system otherwise.</s>
<s id="509">The web frontend has to take care of the task to inform the user about val- idation and conversion errors.</s>
<s id="510">Note, that documents that could not be validated or converted correctly do not enter the repository and, therefore, do not pollute the data collection.</s>
<s id="511">Important is also that users are aware of possible problems and conversion limitations.</s>
<s id="512">This is another task for the interface developed for interacting with LetsMT users.</s>
<s id="513">In many cases it will be difficult to automatically detect errors especially if we allow uploads of arbitrary languages.</s>
<s id="514">Here, again, the web frontend has to enable possibilities to inspect conversion results (at least some snapshots) in order to give users the opportunity to improve or remove noisy content.</s>
<s id="515">5</s>
<s id="516">Risk Analysis</s>
<s id="517">In this document we discuss our plans for the data sharing facilities in LetsMT!</s>
<s id="518">The formats mentioned and described will guide us in the development of the plat- form.</s>
<s id="519">There will be the need to adjust these goals due to unforeseen problems and changes but also according to new developments and opportunities that have been discovered in the course of implementation.</s>
<s id="520">We tried to outline risks already in the introduction and discussed the need for a priority list especially with respect to upload formats.</s>
<s id="521">The most important task for the data sharing facilities is to pro- vide a robust and fast interface to the data repository.</s>
<s id="522">We, therefore, propose to concentrate on a few well supported formats first before adding further formats to the platform.</s>
<s id="523">In this way users will not be disappointed as often by broken and buggy processes and we do not have to count with heavy maintenance tasks when running the system.</s>
<s id="524">Another important point is that users have to be aware of possible problems when uploading data in various formats.</s>
<s id="525">It is necessary to warn them about possible D2.1— v1.1 26 Contract no.</s>
<s id="526">250456 risks and to give them the opportunity to inspect conversion results and to influence the upload and pre-processing steps.</s>
<s id="527">It is crucial to include validation tools for all formats supported and to check all aspects of a user upload in order to identify possible problems and to give feedback in case of detected errors.</s>
<s id="528">Another big risk is the possibility of attacks and damage caused by hackers.</s>
<s id="529">Even though we require user authentication we will not be free of such attacks and we have to be aware of risks that certain file formats bear when we allow arbitrary uploads.</s>
<s id="530">This has to be carefully investigated during implementation and testing.</s>
<s id="531">6 Conclusions</s>
<s id="532">The success of LetsMT!</s>
<s id="533">crucially depends on the data sharing facilities that we will build during the project.</s>
<s id="534">In this deliverable we specify the internal data formats and the structure of the data repository.</s>
<s id="535">We will use a unified format for corpus data and sentence alignment which will be organized in a version-controlled file system.</s>
<s id="536">Data uploads will be supported in a variety of formats.</s>
<s id="537">The implementation will be done in two phases:</s>
<s id="538">Phase 1: Support for uploading pre-aligned parallel corpora in standard formats (TMX, Moses format) and for uploading monolingual data in popular for- mats (DOC, PDF, plain text).</s>
<s id="539">Experimental support for other formats for uploads of monolingual data.</s>
<s id="540">This will enable us to analyze the risks in including them in phase 2 even for parallel data uploads.</s>
<s id="541">Phase 2: Support for uploading unaligned parallel documents in a few popular formats (DOC, PDF, plain text).</s>
<s id="542">Online sentence alignment and possibilities to inspect intermediate results (after conversion, pre-processing, alignment) and possibilities to influence these processing steps (adjusting parameters, selecting alternative tools that have been integrated in LetsMT!).</s>
<s id="543">Start: M</s>
<s id="544">10 Data sharing facilities will be refined until the end of the project.</s>
<s id="545">Additional pre- processing tools will be included and the robustness of the system will be im- proved.</s>
<s id="546">Support of additional formats will also be added as time permits.</s>
<s id="547">D2.1— v1.1 27 Contract no.</s>
<s id="548">250456</s>
<s id="549">References</s>
<s id="550">[1] Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, Franc¸ois Yergeau, and John Cowan.</s>
<s id="551">Extensible Markup Language (XML) 1.1. Tex- tuality and Netscape, Microsoft, W3C &amp; Sun Microsystems, Inc., 2006.</s>
<s id="552">http://www.w3.org/standards/xml/ and http://www.w3.org/TR/xml11.</s>
<s id="553">[2] foolabs.</s>
<s id="554">Xpdf - a toolkit for viewing and processing pdf documents.</s>
<s id="555">http://www.foolabs.com/xpdf/.</s>
<s id="556">[3]</s>
<s id="557">Gnome.</s>
<s id="558">libxml – the xml c parser and toolkit of gnome.</s>
<s id="559">http://www.xmlsoft.org/, 2011.</s>
<s id="560">[4]</s>
<s id="561">Nancy Ide, Keith Suderman, and Laurent Romary.</s>
<s id="562">XCES – Corpus Encoding Standard for XML.</s>
<s id="563">Department of Computer Science, Vassar College, Pough- keepsie NY, USA &amp; Equipe Langue et Dialogue LORIA/CNRS, Vandoeuvre- l`es-Nancy FRANCE, 2008.</s>
<s id="564">http://www.xces.org/.</s>
<s id="565">[5] ISO 639-3:2007 – Codes for the representation of names of languages – Part 3: Alpha-3 code for comprehensive coverage of languages, 2007.</s>
<s id="566">http://www.iso.org/iso/iso catalogue/catalogue tc/catalogue detail.htm?csnumber=39534,</s>
<s id="567">http://www.sil.org/iso639-3/.</s>
<s id="568">[6]</s>
<s id="569">OASIS.</s>
<s id="570">OpenDocument v1.0 specification.</s>
<s id="571">http://www.oasis- open.org/committees/download.php/12572/OpenDocument-v1.0-os.pdf.</s>
<s id="572">[7]</s>
<s id="573">Yves Savoure.</s>
<s id="574">TMX 1.4b Specification – OSCAR Recommen- dation.</s>
<s id="575">The Localisation Industry Standards Association, 2005.</s>
<s id="576">http://www.lisa.org/tmx/tmx.htm.</s>
<s id="577">[8]</s>
<s id="578">Yves Savourel, John Reid, Tony Jewtushenko, and Rodolfo M. Raya.</s>
<s id="579">XLIFF Version 1.2 – OASIS Standard.</s>
<s id="580">Organization for the Advancement of Structured Information Standards (OASIS), 2008.</s>
<s id="581">http://docs.oasis-open.org/xliff/xliff-core/xliff-core.html.</s>
<s id="582">[9]</s>
<s id="583">Unicode, Inc. The Unicode Standard: A Technical Introduction, 2010.</s>
<s id="584">http://www.unicode.org/standard/principles.html.</s>
<s id="585">[10]</s>
<s id="586">Adri van</s>
<s id="587">Os.</s>
<s id="588">On MS Word document readers (antiword), 2008.</s>
<s id="589">http://www.winfield.demon.nl/.</s>
<s id="590">D2.1— v1.1 28</s>
</letsmt>
